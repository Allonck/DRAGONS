% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{appendix} \setcounter{tocdepth}{0}

\title{A User's Guide to Descriptors}
\date{April 07, 2014}
\release{1.0.0}
\author{Emma Hogan}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index-latex::doc}



\chapter{What are Descriptors?}
\label{whataredescriptors:a-user-s-guide-to-descriptors}\label{whataredescriptors::doc}\label{whataredescriptors:what-are-descriptors}\label{whataredescriptors:id1}
Descriptors are designed such that essential keyword values that describe a
particular concept can be accessed from the headers of any dataset in a
consistent manner, regardless of which instrument was used to obtain the
data. This is particularly useful for Gemini data, since the majority of
keywords used to describe a particular concept at Gemini are not uniform
between the instruments.


\chapter{Basic Descriptor Usage}
\label{basicusage:basic-descriptor-usage}\label{basicusage::doc}\label{basicusage:id1}
The command \code{typewalk -l} lists all the descriptors that are defined. As of
the date of this document there are 73 descriptors defined ({\hyperref[appendices/appendixA:appendix-typewalk]{\emph{Appendix A}}}).

The following commands show an example of how to use descriptors. They can be
entered at an interactive Python prompt (e.g., \code{python}, \code{ipython},
\code{pyraf}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{g+go}{\PYGZsh{} Load the fits file into AstroData}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{N20091027S0137.fits}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+go}{\PYGZsh{} Count the number of pixel data extensions in the AstroData object}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ad}\PYG{o}{.}\PYG{n}{count\PYGZus{}exts}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{3}
\PYG{g+go}{\PYGZsh{} Count the number of science extensions in the AstroData object}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ad}\PYG{o}{.}\PYG{n}{count\PYGZus{}exts}\PYG{p}{(}\PYG{n}{extname}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{SCI}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+go}{3}
\PYG{g+go}{\PYGZsh{} Get the airmass value using the airmass descriptor}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{airmass} \PYG{o}{=} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{airmass}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{airmass}
\PYG{g+go}{1.327}
\PYG{g+go}{\PYGZsh{} Get the instrument name using the instrument descriptor}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{My instrument is }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{"} \PYG{o}{\PYGZpc{}} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{instrument}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{My instrument is GMOS-N}
\PYG{g+go}{\PYGZsh{} Get the gain value for each pixel data extension}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{for} \PYG{n}{ext} \PYG{o+ow}{in} \PYG{n}{ad}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print} \PYG{n}{ext}\PYG{o}{.}\PYG{n}{gain}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{2.1}
\PYG{g+go}{2.337}
\PYG{g+go}{2.3}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{gain}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}('SCI', 2): 2.3370000000000002, ('SCI', 1): 2.1000000000000001,}
\PYG{g+go}{('SCI', 3): 2.2999999999999998\PYGZcb{}}
\end{Verbatim}

In the examples above, the airmass and instrument apply to the dataset as a
whole i.e., the keywords themselves exist only in the Primary Header Unit
(PHU) and so only one value is returned. However, the gain applies specifically
to the pixel data extensions within the dataset and so for this AstroData
object, since there are three pixel data extensions, three values are returned
in the form of a Python dictionary, where the key of the dictionary is the
(``\code{EXTNAME}'', \code{EXTVER}) tuple.

For those descriptors that describe a concept applying specifically to the
pixel data extensions within a dataset i.e., those that access keywords in the
headers of the pixel data extensions, a value for every pixel data extension in
the AstroData object is returned by default:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{new\PYGZus{}ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{stgsS20100223S0042.fits}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+go}{\PYGZsh{} Count the number of pixel data extensions in the AstroData object}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{new\PYGZus{}ad}\PYG{o}{.}\PYG{n}{count\PYGZus{}exts}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{103}
\PYG{g+go}{\PYGZsh{} Count the number of science extensions in the AstroData object}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{new\PYGZus{}ad}\PYG{o}{.}\PYG{n}{count\PYGZus{}exts}\PYG{p}{(}\PYG{n}{extname}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{SCI}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+go}{34}
\PYG{g+go}{\PYGZsh{} Get the data section value for each pixel data extension in the form of a}
\PYG{g+go}{\PYGZsh{} dictionary}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{new\PYGZus{}ad}\PYG{o}{.}\PYG{n}{data\PYGZus{}section}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}('SCI', 29): [0, 3108, 0, 22], ('DQ', 5): [0, 3108, 0, 21],}
\PYG{g+go}{('DQ', 9): [0, 3108, 0, 21], ('SCI', 15): [0, 3108, 0, 22],}
\PYG{g+go}{('SCI', 24): [0, 3108, 0, 21], ('VAR', 8): [0, 3108, 0, 21],}
\PYG{g+gp}{...}
\end{Verbatim}

Descriptors can also be used to return values relating to a subset of pixel
data extensions, i.e., those associated with a particular \code{EXTNAME}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{new\PYGZus{}ad}\PYG{o}{.}\PYG{n}{count\PYGZus{}exts}\PYG{p}{(}\PYG{n}{extname}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{DQ}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+go}{34}
\PYG{g+go}{\PYGZsh{} Get the data section value for the data quality extensions only}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{new\PYGZus{}ad}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{DQ}\PYG{l+s}{"}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data\PYGZus{}section}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}('DQ', 11): [0, 3108, 0, 21], ('DQ', 6): [0, 3108, 0, 22],}
\PYG{g+go}{('DQ', 29): [0, 3108, 0, 22], ('DQ', 9): [0, 3108, 0, 21],}
\PYG{g+go}{('DQ', 4): [0, 3108, 0, 22], ('DQ', 19): [0, 3108, 0, 21],}
\PYG{g+gp}{...}
\end{Verbatim}

Note that it is quicker to obtain the values of a descriptor in the form of a
dictionary than it is to obtain the values of a descriptor for each extension
separately.


\chapter{Advanced Descriptor Usage}
\label{advancedusage:advanced-descriptor-usage}\label{advancedusage::doc}\label{advancedusage:id1}

\section{DescriptorValue}
\label{advancedusage:descriptorvalue}
When a descriptor is called, what is actually returned is a \code{DescriptorValue}
(\code{DV}) object:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{g+go}{\PYGZsh{} Load the fits file into AstroData}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{N20091027S0137.fits}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+go}{\PYGZsh{} Get the airmass value using the airmass descriptor}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{airmass} \PYG{o}{=} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{airmass}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{airmass}
\PYG{g+go}{1.327}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{airmass}\PYG{p}{)}
\PYG{g+go}{\textless{}class 'astrodata.Descriptors.DescriptorValue'\textgreater{}}
\end{Verbatim}

Each descriptor has a default Python type defined:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{airmass}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{pytype}
\PYG{g+go}{\textless{}type 'float'\textgreater{}}
\end{Verbatim}

If any of the following operations are applied to the \code{DV} object, the \code{DV}
object is automatically cast to the default Python type for that descriptor:

\begin{Verbatim}[commandchars=\\\{\}]
+   -   *   /   //   \%   **   \textless{}\textless{}   \textgreater{}\textgreater{}   \textasciicircum{}   \textless{}   \textless{}=   \textgreater{}   \textgreater{}=   ==
\end{Verbatim}

For example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{airmass}\PYG{o}{*}\PYG{l+m+mf}{1.0}\PYG{p}{)}
\PYG{g+go}{\textless{}type 'float'\textgreater{}}
\end{Verbatim}

The value of the descriptor can be retrieved with the default Python type by
using \code{as\_pytype()}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{elevation} \PYG{o}{=} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{elevation}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{as\PYGZus{}pytype}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{elevation}
\PYG{g+go}{48.6889222222}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{elevation}\PYG{p}{)}
\PYG{g+go}{\textless{}type 'float'\textgreater{}}
\end{Verbatim}

The \code{as\_pytype()} member function of the \code{DV} object should only be
required when the \code{DV} object can not be automatically cast to it's default
Python type. For example, when it is necessary to use the actual value of a
descriptor (e.g., string, float, etc.) rather than a \code{DV} object as a key of
a Python dictionary, the \code{DV} object can be cast to it's default Python type
using \code{as\_pytype()}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{my\PYGZus{}key} \PYG{o}{=} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{gain\PYGZus{}setting}\PYG{o}{.}\PYG{n}{as\PYGZus{}pytype}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{my\PYGZus{}value} \PYG{o}{=} \PYG{n}{my\PYGZus{}dict}\PYG{p}{[}\PYG{n}{my\PYGZus{}key}\PYG{p}{]}
\end{Verbatim}

If an alternative Python type is required for whatever reason, the \code{DV}
object can be cast to the appropriate Python type as follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{elevation\PYGZus{}as\PYGZus{}int} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{ad}\PYG{o}{.}\PYG{n}{elevation}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{elevation\PYGZus{}as\PYGZus{}int}
\PYG{g+go}{48}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{elevation\PYGZus{}as\PYGZus{}int}\PYG{p}{)}
\PYG{g+go}{\textless{}type 'int'\textgreater{}}
\end{Verbatim}

When using operations with a \code{DV} object and a numpy object, care must be
taken. Consider the following cases:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ad}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data} \PYG{o}{/} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{gain}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ad}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data} \PYG{o}{/} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{gain}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{as\PYGZus{}pytype}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ad}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data} \PYG{o}{/} \PYG{l+m+mf}{12.345}
\end{Verbatim}

All the above commands return the same result (assuming that ad.gain() =
12.345). However, the first command is extremely slow while the second and
third commands are fast. In the first case, since both operands have overloaded
operators, the operator from the operand on the left will be used. For some
reason, the \code{\_\_div\_\_} operator from the numpy object loops over each pixel in
the numpy object and uses the \code{DV} object as an argument, which is very time
consuming. Therefore, the \code{DV} object should be cast to an appropriate
Python type before using it in an operation with a numpy object.

In the case where a descriptor returns multiple values (one for each pixel data
extension), a Python dictionary is used to store the values, where the key of
the dictionary is the (``\code{EXTNAME}'', \code{EXTVER}) tuple:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{gain}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}('SCI', 2): 2.3370000000000002, ('SCI', 1): 2.1000000000000001,}
\PYG{g+go}{('SCI', 3): 2.2999999999999998\PYGZcb{}}
\end{Verbatim}

For those descriptors that describe a concept applying specifically to the
pixel data extensions within a dataset but has the same value for each pixel
data extension will ``act'' as a single value that has a Python type defined by
the default Python type of that descriptor:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{xbin} \PYG{o}{=} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{detector\PYGZus{}x\PYGZus{}bin}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{xbin}
\PYG{g+go}{2}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{xbin}\PYG{p}{)}
\PYG{g+go}{\textless{}class 'astrodata.Descriptors.DescriptorValue'\textgreater{}}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{xbin}\PYG{o}{.}\PYG{n}{pytype}
\PYG{g+go}{\textless{}type 'int'\textgreater{}}
\end{Verbatim}

If the original value of the descriptor is required, it can be retrieved by
using \code{get\_value()}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{xbin} \PYG{o}{=} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{detector\PYGZus{}x\PYGZus{}bin}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{get\PYGZus{}value}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{xbin}
\PYG{g+go}{\PYGZob{}('SCI', 2): 2, ('SCI', 1): 2, ('SCI', 3): 2\PYGZcb{}}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{xbin}\PYG{p}{)}
\PYG{g+go}{\textless{}type 'dict'\textgreater{}}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{xbin}\PYG{p}{[}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{SCI}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}
\PYG{g+go}{2}
\end{Verbatim}


\section{DescriptorUnits}
\label{advancedusage:descriptorunits}
The DescriptorUnits (\code{DU}) object provides a way to access and update the
units for a given descriptor. This feature is not yet implemented, but
development is ongoing.


\chapter{Writing and Adding New Descriptors}
\label{coding:writing-and-adding-new-descriptors}\label{coding:writing-adding}\label{coding::doc}

\section{Overview of the Descriptor Code}
\label{coding:overview-of-the-descriptor-code}
The infrastructure for the descriptor code is located within the \code{astrodata}
subpackage in the \code{gemini\_python} package. In addition, a default set of
descriptors that access FITS standard keywords is provided by \code{astrodata}.
This code is generic and is not Gemini specific.

The Gemini descriptor code is contained within the \code{astrodata\_Gemini} addon
in the \code{gemini\_python} package. The Gemini descriptors inherit the FITS
descriptors, since the Gemini telescopes produce files in FITS format. Other
telescope / instrument addons can exist, enabling the addition of descriptors
from non-Gemini instruments.

The following sections will refer specifically to adding descriptors to the
already existing Gemini descriptor code contained within the
\code{astrodata\_Gemini} addon.


\section{Overview of the FITS Descriptor Code}
\label{coding:overview-of-the-fits-descriptor-code}
The FITS descriptors provide access to those keywords that are part of the FITS
standard. There are currently 53 keywords defined in the FITS standard
(\href{http://heasarc.gsfc.nasa.gov/docs/fcg/standard\_dict.html}{http://heasarc.gsfc.nasa.gov/docs/fcg/standard\_dict.html}). There are four FITS
descriptors available that return the value of the corresponding FITS standard
keywords in the PHU of the AstroData object:
\begin{itemize}
\item {} 
\code{instrument {[}INSTRUME{]}}

\item {} 
\code{object {[}OBJECT{]}}

\item {} 
\code{telescope {[}TELESCOP{]}}

\item {} 
\code{ut\_date {[}DATE-OBS{]}}

\end{itemize}

The FITS descriptor code is currently located in the \code{gemini\_python} package
in the \code{astrodata\_FITS/ADCONFIG\_FITS/descriptors} directory {[}NOTE: the
\code{astrodata\_FITS} directory will be moved to the \code{astrodata} directory in
the near future{]}:
\begin{itemize}
\item {} 
\code{calculatorIndex.FITS.py}

\item {} 
\code{CalculatorInterface\_FITS.py}

\item {} 
\code{DescriptorsList\_FITS.py}

\item {} 
\code{docstrings.py}

\item {} 
\code{FITS\_Descriptors.py}

\item {} 
\code{FITS\_Keywords.py}

\end{itemize}

The function of each of these files is the same as the corresponding files in
the Gemini descriptor code and will be described in the following sections.


\section{Overview of the Gemini Descriptor Code}
\label{coding:overview-of-the-gemini-descriptor-code}
The Gemini descriptors provide access to keywords available in the headers of
Gemini data.

The Gemini descriptor code is located in the \code{gemini\_python} package in the
\code{astrodata\_Gemini/ADCONFIG\_Gemini/descriptors} directory. When writing and
adding new Gemini descriptors, a developer will require knowledge of the
following files:
\begin{itemize}
\item {} 
\code{calculatorIndex.GEMINI.py}

\item {} 
\code{CalculatorInterface\_GEMINI.py}

\item {} 
\code{GEMINI\_Descriptors.py}

\item {} 
\code{GEMINI\_Keywords.py}

\item {} 
\code{\textless{}INSTRUMENT\textgreater{}/\textless{}INSTRUMENT\textgreater{}\_Descriptors.py}

\item {} 
\code{\textless{}INSTRUMENT\textgreater{}/\textless{}INSTRUMENT\textgreater{}\_Keywords.py}

\end{itemize}

The following files are required to create the
\code{CalculatorInterface\_GEMINI.py} file:
\begin{itemize}
\item {} 
\code{astrodata/scripts/mkCalculatorInterface}

\item {} 
\code{DescriptorsList\_GEMINI.py}

\item {} 
\code{docstrings.py}

\end{itemize}


\section{Introduction to the Gemini Descriptor Code}
\label{coding:introduction-to-the-gemini-descriptor-code}
When a descriptor is called (as described in the {\hyperref[basicusage:basic-descriptor-usage]{\emph{Basic Descriptor Usage}}} section and the {\hyperref[advancedusage:advanced-descriptor-usage]{\emph{Advanced Descriptor Usage}}} section), the CalculatorInterface class (\code{CI})
is accessed, which is either contained in the module
\code{CalculatorInterface\_GEMINI.py} or, if this module doesn't exist, is
automatically generated and stored in memory. The \code{CI} contains a function
for each available descriptor (see {\hyperref[appendices/appendixB:appendix-ci]{\emph{Appendix B}}} for an
example function). These functions attempt to determine a value for the
descriptor by performing the following steps:
\begin{itemize}
\item {} 
First, depending on the AstroData Type of the AstroData object, a single
set of keywords and a single set of descriptor functions are determined via
inheritance from the keyword files (\code{\textless{}INSTRUMENT\textgreater{}\_Keywords.py},
\code{GEMINI\_Keywords.py} and \code{FITS\_Keywords.py}) and the descriptor files
(\code{\textless{}INSTRUMENT\textgreater{}\_Descriptor.py}, \code{GEMINI\_Descriptor.py} and
\code{FITS\_Descriptor.py}), respectively, with the files at the start of
each list taking precedence over files later in the list.

\item {} 
If a descriptor function exists in the single set of descriptor functions
determined in the first step for the descriptor being called, then that
descriptor function is used to determine the value of the descriptor.

\item {} 
If no descriptor function is found, the value of a keyword in the PHU of
the AstroData object is returned as the value of the descriptor, where the
keyword is the one directly associated to the descriptor and is contained
in the single set of keywords determined in the first step.

\item {} 
If a value for the descriptor is returned, either from a descriptor
function or directly from the PHU of the AstroData object, a
DescriptorValue (\code{DV}) object is instantiated (which contains the value
of the descriptor) and returns this to the user.

\item {} 
If a value for the descriptor is not found, an exception is raised (see the
{\hyperref[coding:descriptor-exceptions]{\emph{Descriptor Exceptions}}} section).

\end{itemize}

A descriptor function is necessary in the cases where the descriptor does more
than simply access a single keyword from the PHU of the AstroData object, e.g.,
if a descriptor requires access to multiple keywords, requires access to
keywords in the pixel data extensions (a dictionary must be returned by the
descriptor function, where the key is the (``\code{EXTNAME}'', \code{EXTVER}) tuple)
and / or requires some validation.


\section{Description of the files used in the Gemini Descriptor Code}
\label{coding:description-of-the-files-used-in-the-gemini-descriptor-code}

\subsection{\texttt{calculatorIndex.GEMINI.py}}
\label{coding:calculatorindex-gemini-py}\label{coding:id1}
The \code{calculatorIndex.GEMINI.py} file contains a Python dictionary named
\code{calculatorIndex} and is used to define which Python object (i.e., the
descriptor class that defines the descriptor functions, in the form
\code{\textless{}module\_name\textgreater{}.\textless{}calculator\_class\_name\textgreater{}}) to use as the calculator for a given
\code{\textless{}INSTRUMENT\textgreater{}}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{calculatorIndex} \PYG{o}{=} \PYG{p}{\PYGZob{}}
  \PYG{l+s}{"}\PYG{l+s}{\textless{}INSTRUMENT\textgreater{}}\PYG{l+s}{"}\PYG{p}{:}\PYG{l+s}{"}\PYG{l+s}{\textless{}INSTRUMENT\textgreater{}\PYGZus{}Descriptors.\textless{}INSTRUMENT\textgreater{}\PYGZus{}DescriptorCalc()}\PYG{l+s}{"}\PYG{p}{,}
  \PYG{p}{\PYGZcb{}}
\end{Verbatim}

When adding descriptors for a new, undefined instrument, an appropriate entry
must be added to the \code{calculatorIndex} dictionary in the
\code{calculatorIndex.GEMINI.py} file as shown above.


\subsection{\texttt{CalculatorInterface\_GEMINI.py}}
\label{coding:calculatorinterface-gemini-py}
The \code{CalculatorInterface\_GEMINI.py} module contains the CalculatorInterface
class (\code{CI}), which contains a function for each available descriptor (see
{\hyperref[appendices/appendixB:appendix-ci]{\emph{Appendix B}}} for an example function). The
\code{CalculatorInterface\_GEMINI.py} module is automatically generated by the
\code{mkCalculatorInterface} script, which is located in \code{astrodata/scripts}
directory. Therefore, the \code{CalculatorInterface\_GEMINI.py} module should never
be edited directly. If the \code{CalculatorInterface\_GEMINI.py} module does not
exist, the \code{CI} is automatically generated and stored in memory.


\subsection{\texttt{GEMINI\_Keywords.py}}
\label{coding:gemini-keywords-py}
The Gemini specific keyword file \code{GEMINI\_Keywords.py} contains a Python
dictionary named \code{GEMINI\_KeyDict}, where the key is a variable in the form
\code{key\_\textless{}descriptor\textgreater{}} and the value is the keyword directly associated to the
descriptor \code{\textless{}descriptor\textgreater{}}:

\begin{Verbatim}[commandchars=\\\{\}]
GEMINI\_KeyDict = \PYGZob{}
  "key\_airmass":"AIRMASS",
  ...
  "key\_camera":"CAMERA",
  ...
  \PYGZcb{}
\end{Verbatim}

As shown above, the \code{AIRMASS} keyword is associated to the \code{airmass}
descriptor via the variable \code{key\_airmass}. When the \code{airmass} descriptor is
called, the value of the single keyword \code{AIRMASS} in the PHU of the AstroData
object is returned.

If a descriptor function in the Gemini specific descriptor file
\code{GEMINI\_Descriptors.py} requires access to additional keywords, appropriate
variables must be defined in the \code{GEMINI\_KeyDict} dictionary, so that keyword
names are not hard-coded in the descriptor files, allowing a single variable
to be used consistently by multiple descriptor functions:

\begin{Verbatim}[commandchars=\\\{\}]
GEMINI\_KeyDict = \PYGZob{}
  ...
  "key\_pwfs1":"PWFS1\_ST",
  ...
  \PYGZcb{}
\end{Verbatim}


\subsection{\texttt{GEMINI\_Descriptors.py}}
\label{coding:gemini-descriptors-py}
The Gemini specific descriptor file \code{GEMINI\_Descriptors.py} contains
descriptor functions that apply to all Gemini data.


\subsection{\texttt{\textless{}INSTRUMENT\textgreater{}\_Keywords.py}}
\label{coding:instrument-keywords-py}
The instrument specific keyword files \code{\textless{}INSTRUMENT\textgreater{}\_Keywords.py}, which are
located in the corresponding \code{\textless{}INSTRUMENT\textgreater{}} directory in the
\code{astrodata\_Gemini/ADCONFIG\_Gemini/descriptors} directory, contain a Python
dictionary named \code{\textless{}INSTRUMENT\textgreater{}\_KeyDict}, where the key is a variable in the
form \code{key\_\textless{}descriptor\textgreater{}} and the value is the keyword directly associated to
the descriptor \textless{}descriptor\textgreater{}, and is used to overwrite (via inheritance) any of
the Gemini specific keywords directly associated with the descriptor as defined
in \code{GEMINI\_Keywords.py}:

\begin{Verbatim}[commandchars=\\\{\}]
GMOS\_KeyDict = \PYGZob{}
  ...
  "key\_camera":"INSTRUME",
  ...
  \PYGZcb{}
\end{Verbatim}

For GMOS data, the value of the single keyword \code{INSTRUME} in the PHU of the
AstroData object is returned when the \code{camera} descriptor is called, instead
of the value of the single keyword \code{CAMERA}, as defined in the Gemini
specific keyword file \code{GEMINI\_Keywords.py}.

If a descriptor function in the instrument specific descriptor files
\code{\textless{}INSTRUMENT\textgreater{}\_Descriptors.py} require access to additional keywords,
appropriate variables must be defined in the \code{\textless{}INSTRUMENT\textgreater{}\_KeyDict}
dictionary, so that keyword names are not hard-coded in the descriptor files,
allowing a single variable to be used consistently by multiple descriptor
functions:

\begin{Verbatim}[commandchars=\\\{\}]
GMOS\_KeyDict = \PYGZob{}
  ...
  "key\_ccdsum":"CCDSUM",
  ...
  \PYGZcb{}
\end{Verbatim}


\subsection{\texttt{\textless{}INSTRUMENT\textgreater{}\_Descriptors.py}}
\label{coding:instrument-descriptors-py}
The instrument specific descriptor files \code{\textless{}INSTRUMENT\textgreater{}\_Descriptors.py}, which
are located in the corresponding \code{\textless{}INSTRUMENT\textgreater{}} directory in the
\code{astrodata\_Gemini/ADCONFIG\_Gemini/descriptors} directory, contain descriptor
functions that are specific to \code{\textless{}INSTRUMENT\textgreater{}} and are used to overwrite (via
inheritance) any of the Gemini specific descriptor functions as defined in
\code{GEMINI\_Descriptors.py}. An example descriptor function (\code{detector\_x\_bin})
from \code{GMOS\_Descriptors.py} can be found in {\hyperref[appendices/appendixC:appendix-descriptor]{\emph{Appendix C}}}.


\subsection{\texttt{mkCalculatorInterface}}
\label{coding:mkcalculatorinterface}
The \code{mkCalculatorInterface} script is located in the \code{astrodata/scripts}
directory and contains the code required to automatically generate the
\code{CalculatorInterface\_GEMINI.py} module. To create
\code{CalculatorInterface\_GEMINI.py}, run the following command in the
\code{astrodata\_Gemini/ADCONFIG\_Gemini/descriptors} directory:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{shell}\PYG{o}{\textgreater{}} \PYG{n}{mkCalculatorInterface} \PYG{o}{\textgreater{}} \PYG{n}{CalculatorInterface\PYGZus{}GEMINI}\PYG{o}{.}\PYG{n}{py}
\end{Verbatim}

The \code{mkCalculatorInterface} script uses the information in the
\code{DescriptorsList\_GEMINI.py} file and the \code{docstrings.py} file to create the
\code{CalculatorInterface\_GEMINI.py} module. This script should be run after
making changes to the \code{DescriptorsList\_GEMINI.py} file or the
\code{docstrings.py} file.


\subsection{\texttt{DescriptorsList\_GEMINI.py}}
\label{coding:descriptorslist-gemini-py}
The \code{DescriptorsList\_GEMINI.py} file contains a list of Gemini descriptors
and their default Python type:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}
  \PYG{n}{DD}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{airmass}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{pytype}\PYG{o}{=}\PYG{n+nb}{float}\PYG{p}{)}\PYG{p}{,}
  \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{p}{]}
\end{Verbatim}

The \code{DescriptorsList\_GEMINI.py} file is used by the \code{mkCalculatorInterface}
script to generate a function for every descriptor in the
\code{CalculatorInterface\_Gemini.py} file.


\subsection{\texttt{docstrings.py}}
\label{coding:docstrings-py}
The \code{docstrings.py} file contains a function for every Gemini descriptor (as
listed in the \code{DescriptorsList\_GEMINI.py} file) where the docstring for each
descriptor can be defined. The \code{docstrings.py} file is used by the
\code{mkCalculatorInterface} script to include the docstrings for the descriptor
functions in the \code{CalculatorInterface\_Gemini.py} file.


\section{How to add a new Gemini descriptor}
\label{coding:how-to-add-a-new-gemini-descriptor}
The following instructions describe how to add a new descriptor to the system.
\begin{enumerate}
\item {} 
First, check to see whether the new descriptor has the same concept as a
descriptor that already exists ({\hyperref[appendices/appendixA:appendix-typewalk]{\emph{Appendix A}}}). If
a new descriptor is required, edit the \code{DescriptorsList\_GEMINI.py} file
and add the new descriptor to the list in alphabetical order. Ensure that
the default Python type for the descriptor is defined:

\begin{Verbatim}[commandchars=\\\{\}]
[
  ...
  DD("\textless{}my\_descriptor\_name\textgreater{}", pytype=str),
  ...
]
\end{Verbatim}

\item {} 
Add a function with the same name as the new descriptor to the
\code{docstrings.py} file and write a docstring for the new descriptor so
that it can be included in the \code{CalculatorInterface\_GEMINI.py} file.

\item {} 
Regenerate the \code{CalculatorInterface\_GEMINI.py} file:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{shell}\PYG{o}{\textgreater{}} \PYG{n}{mkCalculatorInterface} \PYG{o}{\textgreater{}} \PYG{n}{CalculatorInterface\PYGZus{}GEMINI}\PYG{o}{.}\PYG{n}{py}
\end{Verbatim}

\item {} 
If the new descriptor is for a new, undefined \code{\textless{}INSTRUMENT\textgreater{}}, create an
\code{\textless{}INSTRUMENT\textgreater{}} directory containing an \code{\textless{}INSTRUMENT\textgreater{}\_Descriptors.py}
file:

\begin{Verbatim}[commandchars=\\\{\}]
from GEMINI\_Descriptors import GEMINI\_DescriptorCalc
from \textless{}INSTRUMENT\textgreater{}\_Keywords import \textless{}INSTRUMENT\textgreater{}\_KeyDict

class \textless{}INSTRUMENT\textgreater{}\_DescriptorCalc(GEMINI\_DescriptorCalc):
    \# Updating the global key dictionary with the local key dictionary
    \# associated with this descriptor class
    \_update\_stdkey\_dict = \textless{}INSTRUMENT\textgreater{}\_KeyDict
\end{Verbatim}

and an \code{\textless{}INSTRUMENT\textgreater{}\_Keywords.py} file:

\begin{Verbatim}[commandchars=\\\{\}]
\textless{}INSTRUMENT\textgreater{}\_KeyDict = \PYGZob{}\PYGZcb{}
\end{Verbatim}

In addition, add an appropriate entry to the \code{calculatorIndex.Gemini.py}
file.

\item {} 
If the new descriptor simply returns the value of a single keyword in the
PHU of the AstroData object, check whether the correct keyword is already
defined in the \code{GEMINI\_KeyDict} dictionary in the keyword file
\code{GEMINI\_Keywords.py}. If not, add an entry to the
\code{\textless{}INSTRUMENT\textgreater{}\_KeyDict} dictionary in the instrument specific keyword
file \code{\textless{}INSTRUMENT\textgreater{}\_Keywords.py}, specifying the new descriptor and the
associated keyword:

\begin{Verbatim}[commandchars=\\\{\}]
\textless{}INSTRUMENT\textgreater{}\_KeyDict = \PYGZob{}
  "key\_\textless{}my\_descriptor\_name\textgreater{}":"MYKEYWRD",
\PYGZcb{}
\end{Verbatim}

The descriptor can now be tested; go to step 7.

\item {} 
If the new descriptor requires access to multiple keywords, requires
access to keywords in the pixel data extensions and / or requires some
validation, a descriptor function must be created. Depending on the type
of information the new descriptor will provide, edit one of the following
files to include the new descriptor function:
\begin{itemize}
\item {} 
\code{GEMINI\_Descriptor.py}

\item {} 
\code{\textless{}INSTRUMENT\textgreater{}\_Descriptor.py}

\end{itemize}

If access to a particular keyword is required, first check the keyword
files (\code{FITS\_Keywords.py}, \code{GEMINI\_Keywords.py} and
\code{\textless{}INSTRUMENT\textgreater{}\_Keywords.py}) to see if it has already been defined. If
required, the \code{\textless{}INSTRUMENT\textgreater{}\_Keywords.py} file should be edited to
contain any new keywords required for this new descriptor function.

\item {} 
Test the descriptor:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{N20091027S0137.fits}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{ad}\PYG{o}{.}\PYG{o}{\textless{}}\PYG{n}{my\PYGZus{}descriptor\PYGZus{}name}\PYG{o}{\textgreater{}}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\end{enumerate}


\section{Descriptor Coding Guidelines}
\label{coding:descriptor-coding-guidelines}
When creating descriptor functions, the guidelines below should be followed:
\begin{enumerate}
\item {} 
Return value
\begin{itemize}
\item {} 
The descriptors will return the correct value, regardless of the data
processing status of the AstroData object.

\item {} 
The descriptors will not write keywords to the headers of the AstroData
object or cache any information, since it is no effort to use the
descriptors to obtain the correct value as and when it is required.

\item {} 
The value of a descriptor can be written to the history, for information
only.

\end{itemize}

\item {} 
Return value Python type
\begin{itemize}
\item {} 
The descriptors will always return a \code{DV} object to the user.

\item {} 
The \code{DV} object is instantiated by the \code{CI} for descriptors that
obtain their values directly from the headers of the AstroData object.
For descriptors that obtain their values from the descriptor functions,
the descriptor functions should be coded to return a \code{DV} object. The
\code{DV} object contains information related to the descriptor, including
the value of the descriptor, the default Python type for that descriptor
and the units of the descriptor.

\end{itemize}

\item {} 
Keyword access
\begin{itemize}
\item {} 
The \code{phu\_get\_key\_value} and \code{get\_key\_value} AstroData member
functions should be used in the descriptor functions to access keywords
in the PHU and the headers of the pixel data extensions, respectively,
of an AstroData object.

\end{itemize}

\item {} 
Logging
\begin{itemize}
\item {} 
Descriptors will not log any messages.

\end{itemize}

\item {} 
Raising exceptions
\begin{itemize}
\item {} 
If the value of a descriptor can not be determined for whatever reason,
the descriptor function should raise an exception.

\item {} 
The descriptor functions should never be coded to return None. Instead,
a descriptor function should throw an exception with a message
explaining why a value could not be returned (e.g., if the concept does
not directly apply to the data). An exception thrown from a descriptor
function will be caught by the \code{CI}.

\end{itemize}

\item {} 
Exception rule
\begin{itemize}
\item {} 
Descriptors should throw exceptions on fatal errors.

\item {} 
Exceptions thrown on fatal errors (e.g., if a descriptor function is not
found in a loaded calculator) should never be caught by the \code{CI}. The
high level code, such as a script or a primitive, should catch any
relevant exceptions.

\end{itemize}

\item {} 
Descriptor names
\begin{itemize}
\item {} 
Descriptor names will be:
\begin{itemize}
\item {} 
all lower case

\item {} 
terms separated with ``\_''

\item {} 
not instrument specific

\item {} 
not mode specific, mostly

\end{itemize}

\item {} 
A descriptor should describe a particular concept and apply for all
instrument modes.

\end{itemize}

\item {} 
Standard parameters
\begin{itemize}
\item {} 
Descriptors accept parameters, some with general purposes are
standardized.

\item {} 
It is especially important for descriptor parameters to follow the
Standard Parameter Names
(\href{http://gdpsg.wikis-internal.gemini.edu/index.php/GDPSG-NamingConventions\#Standard\_Parameter\_Names}{http://gdpsg.wikis-internal.gemini.edu/index.php/GDPSG-NamingConventions\#Standard\_Parameter\_Names}) as they are front-facing to the user and should
therefore be consistent.

\end{itemize}

\end{enumerate}


\section{Descriptor Exceptions}
\label{coding:descriptor-exceptions}\label{coding:id2}
When writing descriptor functions, if a descriptor is unable to return a value,
an exception should be raised in the code with an appropriate, explicit error
message, so that it is clear to the user exactly why a value could not be
returned. The exception information is stored in \code{exception\_info} by the
\code{CI} so that a user can access that information, if they wish to do so. A
list of descriptor exceptions can be found in the \code{astrodata/Errors.py}
module. These descriptor exceptions inherit from the DescriptorError base class
and are caught by the \code{CI}. If the default setting of \code{throwExceptions =
False} (line 62 in \code{astrodata/Calculator.py}), \code{None} is returned. During
development, the developer should set \code{throwExceptions = True} so that
exceptions are thrown.
% Set up the appendix mode and modify the LaTeX toc behavior
\appendix
\noappendicestocpagenum
\addappheadtotoc

\chapter{A Complete List of Available Descriptors}
\label{appendices/appendixA:a-complete-list-of-available-descriptors}\label{appendices/appendixA::doc}\label{appendices/appendixA:appendix-typewalk}
Descriptors are designed such that essential keyword values that describe a
particular concept can be accessed from the headers of any dataset in a
consistent manner, regardless of which instrument was used to obtain the
data. This is particularly useful for Gemini data, since the majority of
keywords used to describe a particular concept at Gemini are not uniform
between the instruments.

\code{airmass}
\begin{itemize}
\item {} 
the mean airmass of the observation

\end{itemize}

\code{amp\_read\_area}
\begin{itemize}
\item {} 
the composite string containing the name of the array amplifier and the
readout area of the array used for the observation

\end{itemize}

\code{array\_section}
\begin{itemize}
\item {} 
the unbinned section (in the form of a Python list of integers that uses
0-based indexing as default) of the array that was used to observe the data

\end{itemize}

\code{azimuth}
\begin{itemize}
\item {} 
the azimuth (in degrees between 0 and 360) of the observation

\end{itemize}

\code{bias\_level}
\begin{itemize}
\item {} 
the bias level (in ADU) of the observation

\end{itemize}

\code{camera}
\begin{itemize}
\item {} 
the camera used for the observation

\end{itemize}

\code{cass\_rotator\_pa}
\begin{itemize}
\item {} 
the cassegrain rotator position angle (in degrees between -360 and 360) of
the observation

\end{itemize}

\code{central\_wavelength}
\begin{itemize}
\item {} 
the central wavelength (in meters as default) of the observation

\end{itemize}

\code{coadds}
\begin{itemize}
\item {} 
the number of coadds used for the observation

\end{itemize}

\code{data\_label}
\begin{itemize}
\item {} 
the unique identifying name (e.g., GN-2003A-C-2-52-003) of the observation

\end{itemize}

\code{data\_section}
\begin{itemize}
\item {} 
the section (in the form of a Python list of integers that uses 0-based
indexing as default) of the pixel data extensions that contains the data
observed

\end{itemize}

\code{decker}
\begin{itemize}
\item {} 
the decker position used for the observation

\end{itemize}

\code{dec}
\begin{itemize}
\item {} 
the declination (in decimal degrees) of the observation

\end{itemize}

\code{detector\_name}
\begin{itemize}
\item {} 
the name of each array used for the observation

\end{itemize}

\code{detector\_roi\_setting}
\begin{itemize}
\item {} 
the human-readable description of the detector Region Of Interest (ROI)
setting (either `Full Frame', `CCD2', `Central Spectrum', `Central Stamp',
`Custom', `Undefined' or `Fixed'), which corresponds to the name of the ROI
in the OT

\end{itemize}

\code{detector\_rois\_requested}
\begin{itemize}
\item {} 
the requested detector Region Of Interest (ROI)s of the observation

\end{itemize}

\code{detector\_section}
\begin{itemize}
\item {} 
the unbinned section (in the form of a Python list of integers that uses
0-based indexing as default) of the detector that was used to observe the
data

\end{itemize}

\code{detector\_x\_bin}
\begin{itemize}
\item {} 
the binning of the x-axis of the detector used for the observation

\end{itemize}

\code{detector\_y\_bin}
\begin{itemize}
\item {} 
the binning of the y-axis of the detector used for the observation

\end{itemize}

\code{disperser}
\begin{itemize}
\item {} 
the disperser used for the observation - difference between
disperser/grating/prism? when should someone use disperser? \textbf{*******************************************}

\end{itemize}

\code{dispersion\_axis}
\begin{itemize}
\item {} 
the dispersion axis (along rows, x = 1; along columns, y = 2; along planes,
z = 3) of the observation.

\end{itemize}

\code{dispersion}
\begin{itemize}
\item {} 
the dispersion (in meters per pixel as default) of the observation

\end{itemize}

\code{elevation}
\begin{itemize}
\item {} 
the elevation (in degrees) of the observation

\end{itemize}

\code{exposure\_time}
\begin{itemize}
\item {} 
the total exposure time (in seconds) of the observation

\end{itemize}

\code{filter\_name}
\begin{itemize}
\item {} 
the unique filter name identifier string used for the observation; when
multiple filters are used, the filter names are concatenated with an
ampersand

\end{itemize}

\code{focal\_plane\_mask}
\begin{itemize}
\item {} 
the focal plane mask used for the observation

\end{itemize}

\code{gain}
\begin{itemize}
\item {} 
the gain (in electrons per ADU) of the observation

\end{itemize}

\code{gain\_setting}
\begin{itemize}
\item {} 
the gain setting (either `high' or `low') of the observation

\end{itemize}

\code{grating}
\begin{itemize}
\item {} 
the grating used for the observation

\end{itemize}

\code{group\_id}
\begin{itemize}
\item {} 
the unique string that describes which stack a dataset belongs to; it is
based on the observation\_id

\end{itemize}

\code{instrument}
\begin{itemize}
\item {} 
the instrument used for the observation

\end{itemize}

\code{local\_time}
\begin{itemize}
\item {} 
the local time (in HH:MM:SS.S) at the start of the observation

\end{itemize}

\code{mdf\_row\_id}
\begin{itemize}
\item {} 
the corresponding reference row in the Mask Definition File (MDF)

\end{itemize}

\code{nod\_count}
\begin{itemize}
\item {} 
the number of nod and shuffle cycles in the nod and shuffle observation

\end{itemize}

\code{nod\_pixels}
\begin{itemize}
\item {} 
the number of pixel rows the charge is shuffled by in the nod and shuffle
observation

\end{itemize}

\code{nominal\_atmospheric\_extinction}
\begin{itemize}
\item {} 
the nominal atmospheric extinction (defined as coeff * (airmass - 1.0), where
coeff is the site and filter specific nominal atmospheric extinction
coefficient) of the observation

\end{itemize}

\code{nominal\_photometric\_zeropoint}
\begin{itemize}
\item {} 
the nominal photometric zeropoint of the observation

\end{itemize}

\code{non\_linear\_level}
\begin{itemize}
\item {} 
the non linear level in the raw images (in ADU) of the observation

\end{itemize}

\code{object}
\begin{itemize}
\item {} 
the name of the target object observed

\end{itemize}

\code{observation\_class}
\begin{itemize}
\item {} 
the class (either `science', `progCal', `partnerCal', `acq', `acqCal' or
`dayCal') of the observation

\end{itemize}

\code{observation\_epoch}
\begin{itemize}
\item {} 
the epoch (in years) at the start of the observation

\end{itemize}

\code{observation\_id}
\begin{itemize}
\item {} 
the ID (e.g., GN-2011A-Q-123-45) of the observation; it is used by group\_id

\end{itemize}

\code{observation\_type}
\begin{itemize}
\item {} 
the type (either `OBJECT', `DARK', `FLAT', `ARC', `BIAS' or `MASK') of the
observation

\end{itemize}

\code{overscan\_section}
\begin{itemize}
\item {} 
the section (in the form of a Python list of integers that uses 0-based
indexing as default) of the pixel data extensions that contains the overscan
data

\end{itemize}

\code{pixel\_scale}
\begin{itemize}
\item {} 
the pixel scale (in arcsec per pixel) of the observation

\end{itemize}

\code{prism}
\begin{itemize}
\item {} 
the prism used for the observation

\end{itemize}

\code{program\_id}
\begin{itemize}
\item {} 
the Gemini program ID (e.g., GN-2011A-Q-123) of the observation

\end{itemize}

\code{pupil\_mask}
\begin{itemize}
\item {} 
the pupil mask used for the observation

\end{itemize}

\code{qa\_state}
\begin{itemize}
\item {} 
the quality assessment state (either `Undefined', `Pass', `Usable', `Fail' or
`CHECK') of the observation

\end{itemize}

\code{ra}
\begin{itemize}
\item {} 
the Right Ascension (in decimal degrees) of the observation

\end{itemize}

\code{raw\_bg}
\begin{itemize}
\item {} 
the raw background (as an integer percentile value) of the observation

\end{itemize}

\code{raw\_cc}
\begin{itemize}
\item {} 
the raw cloud cover (as an integer percentile value) of the observation

\end{itemize}

\code{raw\_iq}
\begin{itemize}
\item {} 
the raw image quality (as an integer percentile value) of the observation

\end{itemize}

\code{raw\_wv}
\begin{itemize}
\item {} 
the raw water vapour (as an integer percentile value) of the observation

\end{itemize}

\code{read\_mode}
\begin{itemize}
\item {} 
the read mode (either `Very Faint Object(s)', `Faint Object(s)', `Medium
Object', `Bright Object(s)', `Very Bright Object(s)', `Low Background',
`Medium Background', `High Background' or `Invalid') of the observation

\end{itemize}

\code{read\_noise}
\begin{itemize}
\item {} 
the estimated readout noise (in electrons) of the observation

\end{itemize}

\code{read\_speed\_setting}
\begin{itemize}
\item {} 
the read speed setting (either `fast' or `slow') of the observation

\end{itemize}

\code{requested\_bg}
\begin{itemize}
\item {} 
the requested background (as an integer percentile value) of the observation

\end{itemize}

\code{requested\_cc}
\begin{itemize}
\item {} 
the requested cloud cover (as an integer percentile value) of the observation

\end{itemize}

\code{requested\_iq}
\begin{itemize}
\item {} 
the requested image quality (as an integer percentile value) of the
observation

\end{itemize}

\code{requested\_wv}
\begin{itemize}
\item {} 
the requested water vapour (as an integer percentile value) of the
observation

\end{itemize}

\code{saturation\_level}
\begin{itemize}
\item {} 
the saturation level (in ADU) of the observation

\end{itemize}

\code{slit}
\begin{itemize}
\item {} 
the name of the slit used for the observation

\end{itemize}

\code{telescope}
\begin{itemize}
\item {} 
the telescope used for the observation

\end{itemize}

\code{ut\_date}
\begin{itemize}
\item {} 
the UT date (as a datetime object) at the start of the observation

\end{itemize}

\code{ut\_datetime}
\begin{itemize}
\item {} 
the UT date and time (as a datetime object) at the start of the observation

\end{itemize}

\code{ut\_time}
\begin{itemize}
\item {} 
the UT time (as a datetime object) at the start of the observation

\end{itemize}

\code{wavefront\_sensor}
\begin{itemize}
\item {} 
the wavefront sensor (either `AOWFS', `OIWFS', `PWFS1', `PWFS2', some
combination in alphabetic order separated with an ampersand or None) used for
the observation

\end{itemize}

\code{wavelength\_band}
\begin{itemize}
\item {} 
the wavelength band name (e.g., J, V, R, N) of the observation

\end{itemize}

\code{wavelength\_reference\_pixel}
\begin{itemize}
\item {} 
the 1-based reference pixel of the central wavelength of the observation

\end{itemize}

\code{well\_depth\_setting}
\begin{itemize}
\item {} 
the well depth setting (either `Shallow', `Deep' or `Invalid') of the
observation

\end{itemize}

\code{x\_offset}
\begin{itemize}
\item {} 
the telescope offset in x (in arcsec) of the observation

\end{itemize}

\code{y\_offset}
\begin{itemize}
\item {} 
the telescope offset in y (in arcsec) of the observation

\end{itemize}


\chapter{An Example Function from \texttt{CalculatorInterface\_GEMINI.py}}
\label{appendices/appendixB:an-example-function-from-calculatorinterface-gemini-py}\label{appendices/appendixB::doc}\label{appendices/appendixB:appendix-ci}
The example function below is auto-generated by the
\code{mkCalculatorInterface} script. The \code{CalculatorInterface\_GEMINI.py} file
should never be edited directly.

\begin{Verbatim}[commandchars=\\\{\}]
def airmass(self, format=None, **args):
    """
    Return the airmass value

    :param dataset: the data set
    :type dataset: AstroData
    :param format: the return format
    :type format: string
    :rtype: float as default (i.e., format=None)
    :return: the mean airmass of the observation
    """
    try:
        self.\_lazyloadCalculator()
        keydict = self.descriptor\_calculator.\_specifickey\_dict
        key = "key\_airmass"
        keyword = None
        if key in keydict.keys():
            keyword = keydict[key]

        if not hasattr(self.descriptor\_calculator, "airmass"):
            if keyword is not None:
                retval = self.phu\_get\_key\_value(keyword)
                if retval is None:
                    if hasattr(self, "exception\_info"):
                        raise Errors.DescriptorError(self.exception\_info)
            else:
                msg = ("Unable to find an appropriate descriptor "
                       "function or a default keyword for airmass")
                raise Errors.DescriptorError(msg)
        else:
            try:
                retval = self.descriptor\_calculator.airmass(self, **args)
            except Exception as e:
                raise Errors.DescriptorError(e)


        ret = DescriptorValue( retval,
                               format = format,
                               name = "airmass",
                               keyword = keyword,
                               ad = self,
                               pytype = float )
        return ret

    except Errors.DescriptorError:
        if self.descriptor\_calculator.throwExceptions == True:
            raise
        else:
            if not hasattr(self, \PYGZbs{}"exception\_info\PYGZbs{}"):
                setattr(self, \PYGZbs{}"exception\_info\PYGZbs{}", sys.exc\_info()[1])
            return None
    except:
        raise
\end{Verbatim}


\chapter{An Example Descriptor Function from \texttt{GMOS\_Descriptor.py}}
\label{appendices/appendixC:appendix-descriptor}\label{appendices/appendixC::doc}\label{appendices/appendixC:an-example-descriptor-function-from-gmos-descriptor-py}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{Errors}
\PYG{k+kn}{from} \PYG{n+nn}{GMOS\PYGZus{}Keywords} \PYG{k+kn}{import} \PYG{n}{GMOS\PYGZus{}KeyDict}
\PYG{k+kn}{from} \PYG{n+nn}{GEMINI\PYGZus{}Descriptors} \PYG{k+kn}{import} \PYG{n}{GEMINI\PYGZus{}DescriptorCalc}

\PYG{k}{class} \PYG{n+nc}{GMOS\PYGZus{}DescriptorCalc}\PYG{p}{(}\PYG{n}{GEMINI\PYGZus{}DescriptorCalc}\PYG{p}{)}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} Updating the global key dictionary with the local key dictionary}
    \PYG{c}{\PYGZsh{} associated with this descriptor class}
    \PYG{n}{\PYGZus{}update\PYGZus{}stdkey\PYGZus{}dict} \PYG{o}{=} \PYG{n}{GMOS\PYGZus{}KeyDict}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{GEMINI\PYGZus{}DescriptorCalc}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{detector\PYGZus{}x\PYGZus{}bin}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{dataset}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{args}\PYG{p}{)}\PYG{p}{:}
        \PYG{c}{\PYGZsh{} Since this descriptor function accesses keywords in the headers of}
        \PYG{c}{\PYGZsh{} the pixel data extensions, always return a dictionary where the key}
        \PYG{c}{\PYGZsh{} of the dictionary is an (EXTNAME, EXTVER) tuple}
        \PYG{n}{ret\PYGZus{}detector\PYGZus{}x\PYGZus{}bin} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

        \PYG{c}{\PYGZsh{} Determine the ccdsum keyword from the global keyword dictionary}
        \PYG{n}{keyword} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}descriptor\PYGZus{}key}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{key\PYGZus{}ccdsum}\PYG{l+s}{"}\PYG{p}{)}

        \PYG{c}{\PYGZsh{} Get the value of the ccdsum keyword from the header of each pixel}
        \PYG{c}{\PYGZsh{} data extension as a dictionary}
        \PYG{n}{ccdsum\PYGZus{}dict} \PYG{o}{=} \PYG{n}{gmu}\PYG{o}{.}\PYG{n}{get\PYGZus{}key\PYGZus{}value\PYGZus{}dict}\PYG{p}{(}\PYG{n}{dataset}\PYG{p}{,} \PYG{n}{keyword}\PYG{p}{)}

        \PYG{k}{if} \PYG{n}{ccdsum\PYGZus{}dict} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
            \PYG{c}{\PYGZsh{} The get\PYGZus{}key\PYGZus{}value\PYGZus{}dict() function returns None if a value}
            \PYG{c}{\PYGZsh{} cannot be found and stores the exception info. Re-raise the}
            \PYG{c}{\PYGZsh{} exception. It will be dealt with by the CalculatorInterface.}
            \PYG{k}{if} \PYG{n+nb}{hasattr}\PYG{p}{(}\PYG{n}{dataset}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{exception\PYGZus{}info}\PYG{l+s}{"}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{raise} \PYG{n}{dataset}\PYG{o}{.}\PYG{n}{exception\PYGZus{}info}

        \PYG{k}{for} \PYG{n}{ext\PYGZus{}name\PYGZus{}ver}\PYG{p}{,} \PYG{n}{ccdsum} \PYG{o+ow}{in} \PYG{n}{ccdsum\PYGZus{}dict}\PYG{o}{.}\PYG{n}{iteritems}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{if} \PYG{n}{ccdsum} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
                \PYG{n}{detector\PYGZus{}x\PYGZus{}bin} \PYG{o}{=} \PYG{n+nb+bp}{None}
            \PYG{k}{else}\PYG{p}{:}
                \PYG{c}{\PYGZsh{} Use the binning of the x-axis integer as the value}
                \PYG{n}{detector\PYGZus{}x\PYGZus{}bin}\PYG{p}{,} \PYG{n}{detector\PYGZus{}y\PYGZus{}bin} \PYG{o}{=} \PYG{n}{ccdsum}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}

            \PYG{c}{\PYGZsh{} Update the dictionary with the binning of the x-axis value}
            \PYG{n}{ret\PYGZus{}detector\PYGZus{}x\PYGZus{}bin}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n}{ext\PYGZus{}name\PYGZus{}ver}\PYG{p}{:}\PYG{n}{detector\PYGZus{}x\PYGZus{}bin}\PYG{p}{\PYGZcb{}}\PYG{p}{)}

        \PYG{k}{return} \PYG{n}{ret\PYGZus{}detector\PYGZus{}x\PYGZus{}bin}
\end{Verbatim}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
