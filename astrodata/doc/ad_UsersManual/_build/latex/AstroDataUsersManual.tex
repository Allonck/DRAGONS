% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{appendix} \setcounter{tocdepth}{0}

\title{AstroData Users Manual}
\date{April 07, 2014}
\release{0.9.0}
\author{Kathleen Labrie}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index-latex::doc}



\chapter{Introduction}
\label{intro:introduction}\label{intro::doc}\label{intro:astrodata-user-s-manual}

\section{What is AstroData?}
\label{intro:what-is-astrodata}
(use language a scientist will comprehend.  then either refer to the programmer's reference
or add a section clearly advertised to programmers.  the idea is that we don't want to lose
the scientists, but if some readers are more technically oriented we also want to make sure
they get the info they are after.)


\section{Installing AstroData}
\label{intro:installing-astrodata}
(pre-requisites, build, install, configure)


\section{AstroData Support}
\label{intro:astrodata-support}
(online webpage, gemini helpdesk)


\chapter{Tutorial}
\label{tutorial::doc}\label{tutorial:tutorial}

\section{Open and Access MEF Files}
\label{tutorial:open-and-access-mef-files}
from astrodata import AstroData


\section{Operate on MEF Files}
\label{tutorial:operate-on-mef-files}

\section{Create and Update MEF Files}
\label{tutorial:create-and-update-mef-files}

\section{Writing a Python Function using AstroData}
\label{tutorial:writing-a-python-function-using-astrodata}

\chapter{Input and Output Operations}
\label{io:input-and-output-operations}\label{io::doc}

\section{Open Existing MEF Files}
\label{io:open-existing-mef-files}
An AstroData object can be created from the name of the file on disk or from
PyFITS HDUList.  An existing MEF file can be open as an AstroData object
in \code{readonly}, \code{update}, or \code{append} mode.  The default is \code{readonly}.

\emph{(KL: why would anyone want to create an AD from another AD??!!)}
\emph{(KL: what's the deal with store and storeClobber?  Incomprehensible.)}

Here is a very simple example on how to open a file in \code{readonly} mode,
check the structure, and then close it:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{N20111124S0203.fits}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

To open the file in a mode other than \code{readonly}, specify the value of the
\code{mode} argument:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{N20111124S0203.fits}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{update}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}


\section{Update Existing MEF Files}
\label{io:update-existing-mef-files}
To update an existing MEF file, it must have been opened in the \code{update} mode.  Then a collection
of methods can be applied to the AstroData object.  Here we give examples on how to append an
extension, how to insert an extension, how to remove an extension, and how to replace an extension.
Then we show how do basic arithmetics on the pixel data and the headers in a loop.  Manipulations
of the pixel data and of the headers are covered in more details in later sections (?? and ??, respectively).
Finally we show how to write the updated AstroData object to disk as MEF file.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}

\PYG{c}{\PYGZsh{} Open the file to update}
\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{N20110313S0188.fits}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{update}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Get an already formed extension from another file (just for the}
\PYG{c}{\PYGZsh{} sake of keeping the example simple)}
\PYG{n}{adread} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{N20110316S0321.fits}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{readonly}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{new\PYGZus{}extension} \PYG{o}{=} \PYG{n}{adread}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{SCI}\PYG{l+s}{"}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}

\PYG{c}{\PYGZsh{} Append an extension.}
\PYG{c}{\PYGZsh{} WARNING: new\PYGZus{}extension has EXTNAME=SCI and EXTVER=2}
\PYG{c}{\PYGZsh{}          ad already has an extension SCI,2.}
\PYG{c}{\PYGZsh{}          To avoid conflict, the appended extension needs}
\PYG{c}{\PYGZsh{}          to be renumbered to SCI,4. auto\PYGZus{}number=True takes}
\PYG{c}{\PYGZsh{}          care of that.}
\PYG{c}{\PYGZsh{} WARNING: renumbering the appended extension will affect}
\PYG{c}{\PYGZsh{}          adread as new\PYGZus{}extension is just a pointer to that}
\PYG{c}{\PYGZsh{}          extension in adread.  To avoid the modification of}
\PYG{c}{\PYGZsh{}          adread, one either does the deepcopy before the}
\PYG{c}{\PYGZsh{}          call to append, or set the do\PYGZus{}deepcopy argument}
\PYG{c}{\PYGZsh{}          to True, as we do here.}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{new\PYGZus{}extension}\PYG{p}{,}\PYG{n}{auto\PYGZus{}number}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,}\PYG{n}{do\PYGZus{}deepcopy}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Insert an extension between two already existing extensions.}
\PYG{c}{\PYGZsh{}}
\PYG{c}{\PYGZsh{} Let's first rename the new\PYGZus{}extension to make it stand out once}
\PYG{c}{\PYGZsh{} inserted.}
\PYG{n}{new\PYGZus{}extension} \PYG{o}{=} \PYG{n}{adread}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{new\PYGZus{}extension}\PYG{o}{.}\PYG{n}{rename\PYGZus{}ext}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{VAR}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{new\PYGZus{}extension}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{}   Here we insert the extension between the PHU and the first}
\PYG{c}{\PYGZsh{}   extension.}
\PYG{c}{\PYGZsh{}   WARNING: An AstroData object is a PHU with a list of HDU, the}
\PYG{c}{\PYGZsh{}            extensions. In AstroData, the extension numbering is zero-based.}
\PYG{c}{\PYGZsh{}            Eg. in IRAF myMEF[1] -\textgreater{} in AstroData ad[0]}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{new\PYGZus{}extension}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Note that because the extension was named ('VAR',1) and that did not}
\PYG{c}{\PYGZsh{} conflict with any of the extensions already present, we did not have}
\PYG{c}{\PYGZsh{} to use auto\PYGZus{}number=True.}

\PYG{c}{\PYGZsh{}   Here we insert the extension between the third and the fourth}
\PYG{c}{\PYGZsh{}   extensions.  Again, remember that the extension numbering is}
\PYG{c}{\PYGZsh{}   zero-based.}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{new\PYGZus{}extension}\PYG{p}{,} \PYG{n}{auto\PYGZus{}number}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{do\PYGZus{}deepcopy}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}

\PYG{c}{\PYGZsh{} A ('VAR',1) extension already exists in ad, therefore auto\PYGZus{}number must}
\PYG{c}{\PYGZsh{} be set to True.  Since we are insert the same new\PYGZus{}extension, if we don't}
\PYG{c}{\PYGZsh{} deepcopy it, the EXTVER of the previous insert will also change.}
\PYG{c}{\PYGZsh{} Remember in Python, you might change the name of a variable, but both}
\PYG{c}{\PYGZsh{} will continue pointing to the same data: change one and the other will}
\PYG{c}{\PYGZsh{} change too.}

\PYG{c}{\PYGZsh{} Here we insert the extension between [SCI,3] and [SCI,4]}
\PYG{c}{\PYGZsh{} Note that the position we use for the index is ('SCI',4)}
\PYG{c}{\PYGZsh{} This is because we effectively asking for the new extension}
\PYG{c}{\PYGZsh{} to push ('SCI',4) and take its place in the sequence.}
\PYG{c}{\PYGZsh{}}
\PYG{n}{new\PYGZus{}extension} \PYG{o}{=} \PYG{n}{adread}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{n}{new\PYGZus{}extension}\PYG{o}{.}\PYG{n}{rename\PYGZus{}ext}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{VAR}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{n}{new\PYGZus{}extension}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Now that we have made a nice mess of ad, let's remove some extensions}
\PYG{c}{\PYGZsh{} Removing AstroData extension 4 (0-based array).}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Removing extension ['VAR',5]}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{VAR}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Here is how to replace an extension.}
\PYG{c}{\PYGZsh{} Let's replace extension ('SCI',2) with the ('SCI',2) extension from adread.}

\PYG{c}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} .replace() is broken.  Will add example when it's fixed.}


\PYG{c}{\PYGZsh{} Finally, let's write this modified AstroData object to disk as a MEF file.}
\PYG{c}{\PYGZsh{} The input MEF was open in update mode.  If no file name is provide to the}
\PYG{c}{\PYGZsh{} write command, the file will be overwritten.  To write to a new file,}
\PYG{c}{\PYGZsh{} specify a filename.}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{filename}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{newfile.fits}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{filename}

\PYG{c}{\PYGZsh{} Note that any further write() would now write to 'newfile.fits' if no filename}
\PYG{c}{\PYGZsh{} is specified.}

\PYG{c}{\PYGZsh{} The pixel data and header data obviously can be accessed and modified.}
\PYG{c}{\PYGZsh{} More on pixel data manipulation in ???.  More on header manipulation in ???}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{k}{for} \PYG{n}{extension} \PYG{o+ow}{in} \PYG{n}{ad}\PYG{p}{:}
   \PYG{c}{\PYGZsh{} Obtain a numpy.ndarray. Then any ndarray operations are valid.}
   \PYG{n}{data} \PYG{o}{=} \PYG{n}{ext}\PYG{o}{.}\PYG{n}{data}
   \PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
   \PYG{n}{np}\PYG{o}{.}\PYG{n}{average}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}

   \PYG{c}{\PYGZsh{} Obtain a pyfits header.}
   \PYG{n}{hdr} \PYG{o}{=} \PYG{n}{ext}\PYG{o}{.}\PYG{n}{header}
   \PYG{k}{print} \PYG{n}{hdr}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{NAXIS2}\PYG{l+s}{'}\PYG{p}{)}

\PYG{c}{\PYGZsh{} the numpy.ndarray can also be extracted this way.}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}

\PYG{c}{\PYGZsh{} To close an AstroData object.  It is recommended to properly close the object}
\PYG{c}{\PYGZsh{} when it will no longer be used.}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{adread}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\section{Create New MEF Files}
\label{io:create-new-mef-files}
The method \code{write} is use to write to disk a new MEF file from an AstroData
object.  Here we show two ways to build that new AstroData object and create
a MEF file, in memory or on disk, from that AstroData object.


\subsection{Create New Copy of MEF Files}
\label{io:create-new-copy-of-mef-files}
Let us consider the case where you already have a MEF file on disk and you want
to work on it and write the modified MEF to a new file.

Here we open a file, make a copy, and write a new MEF file on disk:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{N20110313S0188.fits}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{newfile2.fits}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

Since in Python and when working with AstroData objects, the memory can be
shared between variables, it is sometimes necessary to create a ``true'' copy
of an AstroData object to keep us from modifying the original.

By using \code{deepcopy} on an AstroData object the copy is a true copy, it has
its own memory allocation.  This allows one to modify the copy while leave the
original AstroData intact.  This feature is useful when an operation requires
both the modified and the original AstroData object since by design a simple
copy still point to the same location in memory.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{k+kn}{from} \PYG{n+nn}{copy} \PYG{k+kn}{import} \PYG{n}{deepcopy}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{N20110313S0188.fits}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{adcopy} \PYG{o}{=} \PYG{n}{deepcopy}\PYG{p}{(}\PYG{n}{ad}\PYG{p}{)}
\end{Verbatim}

In the example above, \code{adcopy} is now completely independent of \code{ad}.
This also means that you have doubled the memory footprint.


\subsection{Create New MEF Files from Scratch}
\label{io:create-new-mef-files-from-scratch}
Another use case is creating a new MEF files when none existed before. The
pixel data needs to be created as a numpy ndarray.  The header must be created
as pyfits header.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{k+kn}{import} \PYG{n+nn}{pyfits} \PYG{k+kn}{as} \PYG{n+nn}{pf}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{c}{\PYGZsh{} Create an empty header.  AstroData will take care of adding the minimal}
\PYG{c}{\PYGZsh{} set of header cards to make the file FITS compliant.}
\PYG{n}{new\PYGZus{}header} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{Header}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Create a pixel data array.  Fill it with whatever values you need.}
\PYG{c}{\PYGZsh{} Here we just create a fill gradient.}
\PYG{n}{new\PYGZus{}data} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1000.}\PYG{p}{,} \PYG{l+m+mi}{2048}\PYG{o}{*}\PYG{l+m+mi}{1024}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{l+m+mi}{2048}\PYG{p}{,}\PYG{l+m+mi}{1024}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Create an AstroData object and give it a filename}
\PYG{n}{new\PYGZus{}ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{n}{data}\PYG{o}{=}\PYG{n}{new\PYGZus{}data}\PYG{p}{,} \PYG{n}{header}\PYG{o}{=}\PYG{n}{new\PYGZus{}header}\PYG{p}{)}
\PYG{n}{new\PYGZus{}ad}\PYG{o}{.}\PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{'}\PYG{l+s}{gradient.fits}\PYG{l+s}{'}

\PYG{c}{\PYGZsh{} Write the file to disk and close}
\PYG{n}{new\PYGZus{}ad}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{new\PYGZus{}ad}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\chapter{MEF Structure Mapping}
\label{structure:mef-structure-mapping}\label{structure::doc}

\section{File Structure Definitions}
\label{structure:file-structure-definitions}

\section{Gemini Data Structure}
\label{structure:gemini-data-structure}
(SCI, VAR, DQ, MDF)


\section{Using Structures}
\label{structure:using-structures}

\section{Adding New Structure}
\label{structure:adding-new-structure}

\chapter{AstroDataTypes}
\label{types:astrodatatypes}\label{types::doc}

\section{What are AstroDataTypes}
\label{types:what-are-astrodatatypes}
(explain what they are. data type \& data processing status. classification based on headers only.
explain how to install the Gemini types.)


\section{Using AstroDataTypes}
\label{types:using-astrodatatypes}
There are two ways to check the AstroDataTypes of a dataset:

\begin{Verbatim}[commandchars=\\\{\}]
from astrodata import AstroData

ad = AstroData('N20111124S0203.fits')

if ad.is\_type('GMOS\_IMAGING'):
    \# do special steps for GMOS\_IMAGING type data

if 'GMOS\_IMAGING' in ad.types:
    \# do special steps for GMOS\_IMAGING type data
\end{Verbatim}

The attribute \code{ad.types} returns a list of all the AstroDataTypes associated with the dataset.
It can be useful when interactively exploring the various types associated with a dataset, or
when there's a need to write all the types to the screen or to a file, for logging purposes, for example.
Use at your discretion based on your need.

``Data Types'' are referred to as \emph{Typology} in the AstroDataTypes code.  ``Data Processing Status'' are
referred to as \emph{Status}.  There are two additional attributes that might be useful if those two
concepts need to be addressed separately:  \code{ad.typesStatus} and \code{ad.typesTypology}.  They
are used exactly the same way as \code{ad.types}.

??? ad.refresh\_types()


\section{Creating New AstroDataTypes}
\label{types:creating-new-astrodatatypes}
(refer to programmer's manual, but give some idea of what needs to be done
and the basic principles)


\chapter{FITS Headers}
\label{headers::doc}\label{headers:fits-headers}

\section{AstroData Descriptors}
\label{headers:astrodata-descriptors}
AstroData Descriptors provide a ``header keyword-to-concept'' mapping that allows one to
access header information in a consistent manner, regardless of which instrument the
dataset is from.  The mapping is coded in a configuration package that is provided
by the observatory or the user.

For example, if one were interested to know the filter used for an observation, normally
one would need to know which specific keyword or set of keywords to look at.  Once the
concept of ``filter'' is coded in a Descriptor, one now only needs to call the \code{filtername}
Descriptor.

To get the list of descriptors available for an AstroData object:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{N20111124S0203.fits}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{all\PYGZus{}descriptor\PYGZus{}names}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

Most Descriptor names are readily understood, but one can get a short description of
what the Descriptor refers to by call the Python help function, for example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{help}\PYG{p}{(}\PYG{n}{ad}\PYG{o}{.}\PYG{n}{airmass}\PYG{p}{)}
\end{Verbatim}

Descriptors associated with standard FITS keywords are available from the \code{ADCONFIG\_FITS} package
distributed in \code{astrodata\_FITS}.  All the Descriptors associated with other concepts used by
the Gemini software are found in the \code{ADCONFIG\_Gemini} package, part of \code{astrodata\_Gemini}.

As a user reducing Gemini data or coding for existing Gemini data, all you need to do is make
sure that astrodata\_FITS and astrodata\_Gemini have been installed.  If you are coding for a new
Gemini instrument, or for another observatory, Descriptors and AstrodataTypes will need to be
coded.  That's a more advanced topic addressed elsewhere. (KL?? ref to last section of this page)


\section{Accessing Headers}
\label{headers:accessing-headers}
Whenever possible the Descriptors should be used to get information from the headers.  This
allows for maximum re-use of the code as it will work on any datasets with an AstroDataTypes.
Here are a few examples using Descriptors:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{k+kn}{from} \PYG{n+nn}{copy} \PYG{k+kn}{import} \PYG{n}{deepcopy}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{N20111124S0203.fits}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{adcopy} \PYG{o}{=} \PYG{n}{deepcopy}\PYG{p}{(}\PYG{n}{ad}\PYG{p}{)}

\PYG{k}{print} \PYG{l+s}{'}\PYG{l+s}{The airmass is : }\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{ad}\PYG{o}{.}\PYG{n}{airmass}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{if} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{exposure\PYGZus{}time}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\textless{}} \PYG{l+m+mf}{240.}\PYG{p}{:}
  \PYG{k}{print} \PYG{l+s}{'}\PYG{l+s}{This is a short exposure}\PYG{l+s}{'}

\PYG{c}{\PYGZsh{} This call will multiply the pixel values in all three science extensions}
\PYG{c}{\PYGZsh{} by their respective gain.  There's no need to loop through the science}
\PYG{c}{\PYGZsh{} extension explicitly.}
\PYG{n}{adcopy}\PYG{o}{.}\PYG{n}{mult}\PYG{p}{(}\PYG{n}{adcopy}\PYG{o}{.}\PYG{n}{gain}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{fhwm\PYGZus{}arcsec} \PYG{o}{=} \PYG{l+m+mf}{3.5} \PYG{o}{*} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{pixel\PYGZus{}scale}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

Of course not all the header content has been mapped with Descriptors.  Here is how
to get the value of a specific header keyword:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{N20111124S0203.fits}\PYG{l+s}{'}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Get keyword value from the PHU}
\PYG{n}{aofold\PYGZus{}position} \PYG{o}{=} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{phu\PYGZus{}get\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{AOFOLD}\PYG{l+s}{'}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Get keyword value from a specific extension}
\PYG{n}{naxis2} \PYG{o}{=} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{ext\PYGZus{}get\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{NAXIS2}\PYG{l+s}{'}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Get keyword value from an extension when there's only one extension}
\PYG{c}{\PYGZsh{} This happens, for example, when looping through multiple extensions.}
\PYG{k}{for} \PYG{n}{extension} \PYG{o+ow}{in} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{:}
   \PYG{n}{naxis2} \PYG{o}{=} \PYG{n}{extension}\PYG{o}{.}\PYG{n}{get\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{NAXIS2}\PYG{l+s}{'}\PYG{p}{)}
   \PYG{k}{print} \PYG{n}{naxis2}
\end{Verbatim}

Multi-extension FITS files, MEF, have this concept of naming and versioning the extensions.
The header keywords controlling name and version are \code{EXTNAME} and \code{EXTVER}.  AstroData
uses that concept extensively.  See ??? for information on the typical structure of AstroData
objects.  The name and version of an extension is obtained this way:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{name} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{extname}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{version} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{extver}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{name}\PYG{p}{,} \PYG{n}{version}
\end{Verbatim}

To get a whole header from an AstroData object, one would do:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Get the header for the PHU as a pyfits Header object}
\PYG{n}{phuhdr} \PYG{o}{=} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{phu}\PYG{o}{.}\PYG{n}{header}

\PYG{c}{\PYGZsh{} Get the header for extension SCI, 1 as a pyfits Header object}
\PYG{n}{exthdr} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{header}

\PYG{c}{\PYGZsh{} print the header content in the interactive shell}
\PYG{c}{\PYGZsh{} For a specific extension:}
\PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{header}
\PYG{c}{\PYGZsh{} For all the extensions:  (PHU excluded)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{get\PYGZus{}headers}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{ad}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\section{Updating and Adding Headers}
\label{headers:updating-and-adding-headers}
Header cards can be updated or added to header.  As for the access to the headers, the PHU
have their own methods, different from the extension, but essentially doing the same thing.
To write to a PHU use the \code{phu\_set\_key\_value()} method.  To write to the header of an
extension, use the \code{ext\_set\_key\_values()}.  The difference is that one has to specify the
extension ID in the latter case.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{N20111124S0203.fits}\PYG{l+s}{'}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Add a header card to the PHU}
\PYG{c}{\PYGZsh{}  The arguments are *keyword*, *value*, *comment*.  The comment is optional.}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{phu\PYGZus{}set\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{MYTEST}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+m+mi}{99}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{Some meaningless keyword}\PYG{l+s}{'}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Modify a header card in the second extension}
\PYG{c}{\PYGZsh{}  The arguments are *extension*, *keyword*, *value*, *comment*.  The comment}
\PYG{c}{\PYGZsh{}  is optional.  If a comment already exists, it will be left untouched.}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{ext\PYGZus{}set\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{GAIN}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mf}{5.}\PYG{p}{)}

\PYG{c}{\PYGZsh{} The extension can also be specified by name and version.}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{ext\PYGZus{}set\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{GAIN}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+m+mf}{10.}\PYG{p}{)}

\PYG{c}{\PYGZsh{} A utility method also exists for use in astrodata objects that contain}
\PYG{c}{\PYGZsh{} only one extension.  This is particularly useful when looping through}
\PYG{c}{\PYGZsh{} the extensions.  There's no need to specify the extension number since}
\PYG{c}{\PYGZsh{} there's only one.  The arguments are *keyword*, *value*, *comment*, with}
\PYG{c}{\PYGZsh{} comment being optional.}
\PYG{k}{for} \PYG{n}{extension} \PYG{o+ow}{in} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{:}
    \PYG{n}{extension}\PYG{o}{.}\PYG{n}{set\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{TEST}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{This is a test.}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

The name and version of an extension can be set or reset manually with the
\code{rename\_ext} method:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{rename\PYGZus{}ext}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{VAR}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}
\end{Verbatim}

Be careful with this function.  Having two extensions with the same name and
version in an AstroData data object, or a MEF files for that matter, can lead
to strange problems.


\section{Adding Descriptors Definitions for New Instruments}
\label{headers:adding-descriptors-definitions-for-new-instruments}
(refer to Emma's document.)


\chapter{Pixel Data}
\label{data::doc}\label{data:pixel-data}

\section{Operate on the Pixel Data}
\label{data:operate-on-the-pixel-data}
The pixel data is stored as a numpy ndarray.  This means that anything that can be done with numpy on a ndarray
can be done on the pixel data stored in the AstroData object.  Examples include arithmetic, statistics, display,
plotting, etc.  Please refer to numpy documentation for details on what it offers.  In this chapter, we will
present some typical examples.

But first, here's how one accesses the data array stored in an AstroData object:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{N20110313S0188.fits}\PYG{l+s}{'}\PYG{p}{)}

\PYG{c}{\PYGZsh{} The PHU does not have any pixel data.  Only the extensions can have pixel data.}
\PYG{n}{the\PYGZus{}data} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}

\PYG{c}{\PYGZsh{} or to loop through the extensions.  Here we just print the sum of all the pixels}
\PYG{c}{\PYGZsh{} for each extension.}
\PYG{k}{for} \PYG{n}{extension} \PYG{o+ow}{in} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{:}
   \PYG{n}{the\PYGZus{}data} \PYG{o}{=} \PYG{n}{extension}\PYG{o}{.}\PYG{n}{data}
   \PYG{k}{print} \PYG{n}{the\PYGZus{}data}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{ad}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\section{Arithmetic on AstroData Objects}
\label{data:arithmetic-on-astrodata-objects}
AstroData supports basic arithmetic directly: addition, subtraction, multiplication, division.
The big advantage of using the AstroData implementation of those operator is that if the
AstroData object has variance and data quality planes, those will be calculated and propagated
to the output appropriately.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{N20110313S0188.fits}\PYG{l+s}{'}\PYG{p}{)}

\PYG{c}{\PYGZsh{} addition}
\PYG{c}{\PYGZsh{}   ad = ad + 5.}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+m+mf}{5.}\PYG{p}{)}

\PYG{c}{\PYGZsh{} subtraction}
\PYG{c}{\PYGZsh{}   ad = ad - 5.}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{sub}\PYG{p}{(}\PYG{l+m+mf}{5.}\PYG{p}{)}

\PYG{c}{\PYGZsh{} multiplication.  Using descriptor as operand.}
\PYG{c}{\PYGZsh{}   ad = ad * gain}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{mult}\PYG{p}{(}\PYG{n}{ad}\PYG{o}{.}\PYG{n}{gain}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} division. Using descriptor as operand.}
\PYG{c}{\PYGZsh{}   ad = ad / gain}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{div}\PYG{p}{(}\PYG{n}{ad}\PYG{o}{.}\PYG{n}{gain}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

When using the AstroData arithmetic, all the science (EXTNAME='SCI') frames are
operated on.

The AstroData arithmetic methods can be stringed together.  Note that because
the calculations are done ``in-place'', operator precedence cannot be respected.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mult}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sub}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{c}{\PYGZsh{} means:  ad = ((ad + 5) * 10) - 5}
\PYG{c}{\PYGZsh{} not: ad = ad + (5 * 10) - 5}

\PYG{n}{ad}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

The AstroData data arithmetic method modify the data ``in-place''.  This means that the data
values are modified and the original values are no more.  If you need to keep the original
values unmodified, for example, you will need them later, use \code{deepcopy} to make a separate
copy on which you can work.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{k+kn}{from} \PYG{n+nn}{copy} \PYG{k+kn}{import} \PYG{n}{deepcopy}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{N20110313S0188.fits}\PYG{l+s}{'}\PYG{p}{)}

\PYG{c}{\PYGZsh{} To do:  x = x*10 + x}
\PYG{c}{\PYGZsh{}  One must use deepcopy because after the mult(10), 'ad' has been modified}
\PYG{c}{\PYGZsh{}  and it is that modified version that will be use in add(ad)}

\PYG{c}{\PYGZsh{} Let's follow a pixel through the math}

\PYG{n}{value\PYGZus{}before} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{]}
\PYG{n}{expected\PYGZus{}value\PYGZus{}after} \PYG{o}{=} \PYG{n}{value\PYGZus{}before}\PYG{o}{*}\PYG{l+m+mi}{10} \PYG{o}{+} \PYG{n}{value\PYGZus{}before}

\PYG{n}{ad}\PYG{o}{.}\PYG{n}{mult}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{ad}\PYG{p}{)}
\PYG{n}{bad\PYGZus{}value\PYGZus{}after} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{]}

\PYG{k}{print} \PYG{n}{expected\PYGZus{}value\PYGZus{}after}\PYG{p}{,} \PYG{n}{bad\PYGZus{}value\PYGZus{}after}

\PYG{c}{\PYGZsh{} The result of the arithmetic above is x = (x*10) + (x*10)}

\PYG{c}{\PYGZsh{} To do the right thing, one can use {}`{}`deepcopy{}`{}`}
\PYG{c}{\PYGZsh{} First let's reload a fresh ad.}
\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{N20110313S0188.fits}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{adcopy} \PYG{o}{=} \PYG{n}{deepcopy}\PYG{p}{(}\PYG{n}{ad}\PYG{p}{)}

\PYG{n}{ad}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{adcopy}\PYG{o}{.}\PYG{n}{mult}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{good\PYGZus{}value\PYGZus{}after} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{expected\PYGZus{}mean\PYGZus{}after}\PYG{p}{,} \PYG{n}{good\PYGZus{}mean\PYGZus{}after}

\PYG{n}{ad}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{adcopy}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

As one can see, for complex equation, using the AstroData arithmetic method
can get fairly confusing.  Operator overload would solve this situation but
it has not been implemented yet.  Therefore, we recommend to use numpy for
really complex equation since operator overload is implemented and the operator
precedence is respected.  The downside is that if you need the variance plane
propagate correctly, you will have to do the math yourself.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{N20110313S0188.fits}\PYG{l+s}{'}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Let's do 'x = x*10 + x' again but this time we operate directly on}
\PYG{c}{\PYGZsh{} the numpy ndarray return by '.data'.  We will follow a pixel through}
\PYG{c}{\PYGZsh{} the math like before.}

\PYG{n}{value\PYGZus{}before} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{]}
\PYG{n}{expected\PYGZus{}value\PYGZus{}after} \PYG{o}{=} \PYG{n}{value\PYGZus{}before}\PYG{o}{*}\PYG{l+m+mi}{10} \PYG{o}{+} \PYG{n}{value\PYGZus{}before}

\PYG{k}{for} \PYG{n}{extension} \PYG{o+ow}{in} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{:}
    \PYG{n}{data\PYGZus{}array} \PYG{o}{=} \PYG{n}{extension}\PYG{o}{.}\PYG{n}{data}
    \PYG{n}{data\PYGZus{}array} \PYG{o}{=} \PYG{n}{data\PYGZus{}array}\PYG{o}{*}\PYG{l+m+mi}{10} \PYG{o}{+} \PYG{n}{data\PYGZus{}array}
    \PYG{n}{extension}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{data\PYGZus{}array}

\PYG{n}{value\PYGZus{}after} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{expected\PYGZus{}value\PYGZus{}after}\PYG{p}{,} \PYG{n}{value\PYGZus{}after}

\PYG{n}{ad}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\section{Variance}
\label{data:variance}
Here we demonstrate the variance propagation when using AstroData arithmetic methods.
First let us create and append variance planes to our file.  We will just add the poisson
noise and ignore read noise for the purpose of this example.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{k+kn}{from} \PYG{n+nn}{copy} \PYG{k+kn}{import} \PYG{n}{deepcopy}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{N20110313S0188.fits}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{extension} \PYG{o+ow}{in} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{:}
    \PYG{n}{variance} \PYG{o}{=} \PYG{n}{extension}\PYG{o}{.}\PYG{n}{data} \PYG{o}{/} \PYG{n}{extension}\PYG{o}{.}\PYG{n}{gain}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{as\PYGZus{}pytype}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{variance\PYGZus{}header} \PYG{o}{=} \PYG{n}{extension}\PYG{o}{.}\PYG{n}{header}
    \PYG{n}{variance\PYGZus{}extension} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{n}{data}\PYG{o}{=}\PYG{n}{variance}\PYG{p}{,} \PYG{n}{header}\PYG{o}{=}\PYG{n}{variance\PYGZus{}header}\PYG{p}{)}
    \PYG{n}{variance\PYGZus{}extension}\PYG{o}{.}\PYG{n}{rename\PYGZus{}ext}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{VAR}\PYG{l+s}{'}\PYG{p}{)}
    \PYG{n}{ad}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{variance\PYGZus{}extension}\PYG{p}{)}

\PYG{n}{ad}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Let's just save a copy of this ad for later use.}
\PYG{n}{advar} \PYG{o}{=} \PYG{n}{deepcopy}\PYG{p}{(}\PYG{n}{ad}\PYG{p}{)}
\end{Verbatim}

Now let us follow a science pixel and a variance pixel through the AstroData arithmetic.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{}     output = x * x}
\PYG{c}{\PYGZsh{} var\PYGZus{}output = var * x\PYGZca{}2 + var * x\PYGZca{}2}

\PYG{n}{value\PYGZus{}before} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{]}
\PYG{n}{variance\PYGZus{}before} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{VAR}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{]}
\PYG{n}{expected\PYGZus{}value\PYGZus{}after} \PYG{o}{=} \PYG{n}{value\PYGZus{}before} \PYG{o}{+} \PYG{n}{value\PYGZus{}before}
\PYG{n}{expected\PYGZus{}variance\PYGZus{}after} \PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{p}{(}\PYG{n}{variance\PYGZus{}before} \PYG{o}{*} \PYG{n}{value\PYGZus{}before} \PYG{o}{*} \PYG{n}{value\PYGZus{}before}\PYG{p}{)}

\PYG{n}{ad}\PYG{o}{.}\PYG{n}{mult}\PYG{p}{(}\PYG{n}{ad}\PYG{p}{)}

\PYG{n}{value\PYGZus{}after} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{]}
\PYG{n}{variance\PYGZus{}after} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{VAR}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{expected\PYGZus{}value\PYGZus{}after}\PYG{p}{,} \PYG{n}{value\PYGZus{}after}
\PYG{k}{print} \PYG{n}{expected\PYGZus{}variance\PYGZus{}after}\PYG{p}{,} \PYG{n}{variance\PYGZus{}after}

\PYG{n}{ad}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

So all it took to multiply the science extensions by themselves and propagate
the variance accordingly was \code{ad.mult(ad)}.

To do the same thing operating directly on the numpy array:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Let's recall the ad with the variance planes we created earlier}
\PYG{n}{ad} \PYG{o}{=} \PYG{n}{deepcopy}\PYG{p}{(}\PYG{n}{advar}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{ad}\PYG{o}{.}\PYG{n}{count\PYGZus{}exts}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{d} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}
    \PYG{n}{v} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{VAR}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{d}\PYG{o}{*}\PYG{n}{d}
    \PYG{n}{variance} \PYG{o}{=} \PYG{n}{v} \PYG{o}{*} \PYG{n}{d}\PYG{o}{*}\PYG{n}{d} \PYG{o}{+} \PYG{n}{v} \PYG{o}{*} \PYG{n}{d}\PYG{o}{*}\PYG{n}{d}
    \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{data}
    \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{VAR}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{variance}

\PYG{k}{print} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{VAR}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{]}
\end{Verbatim}


\section{Display}
\label{data:display}
Displaying \code{numpy} arrays from Python is straighforward with the \code{numdisplay} module.
The module also has a function to read the position the cursor, which can be useful when
developing an interactive task.

Start a display tool, like DS9 or ximtool. Then try the commands below.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{k+kn}{from} \PYG{n+nn}{numdisplay} \PYG{k+kn}{import} \PYG{n}{display}
\PYG{k+kn}{from} \PYG{n+nn}{numdisplay} \PYG{k+kn}{import} \PYG{n}{readcursor}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{N20110313S0188.fits}\PYG{l+s}{'}\PYG{p}{)}

\PYG{n}{display}\PYG{p}{(}\PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}

\PYG{c}{\PYGZsh{} To scale "a la IRAF"}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,} \PYG{n}{zscale}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}

\PYG{c}{\PYGZsh{} To set the minimum and maximum values to display}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,} \PYG{n}{z1}\PYG{o}{=}\PYG{l+m+mi}{700}\PYG{p}{,} \PYG{n}{z2}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}
\end{Verbatim}

If you need to retrieve cursor position inputs, the numdisplay.readcursor function can help.
It does not respond to mouse clicks, but it does respond to keyboard entries.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Invoke readcursor() and put the cursor on top of the image.}
\PYG{c}{\PYGZsh{} Type any key.}
\PYG{c}{\PYGZsh{} cursor\PYGZus{}coo will contain the x, y positions and in the last column the key that was typed.}
\PYG{n}{cursor\PYGZus{}coo} \PYG{o}{=} \PYG{n}{readcursor}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{cursor\PYGZus{}coo}

\PYG{c}{\PYGZsh{} If you just want to extract the x,y coordinates:}
\PYG{p}{(}\PYG{n}{xcoo}\PYG{p}{,} \PYG{n}{ycoo}\PYG{p}{)} \PYG{o}{=} \PYG{n}{cursor\PYGZus{}coo}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{xcoo}\PYG{p}{,} \PYG{n}{ycoo}

\PYG{c}{\PYGZsh{} If you are also interested in the keystoke:}
\PYG{p}{(}\PYG{n}{xcoo}\PYG{p}{,} \PYG{n}{ycoo}\PYG{p}{,} \PYG{n}{junk}\PYG{p}{,} \PYG{n}{keystroke}\PYG{p}{)} \PYG{o}{=} \PYG{n}{cursor\PYGZus{}coo}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{'}\PYG{l+s}{You pressed this key: }\PYG{l+s}{"}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{"}\PYG{l+s}{'} \PYG{o}{\PYGZpc{}} \PYG{n}{keystroke}
\end{Verbatim}


\section{Useful tools from the Numpy and SciPy Modules}
\label{data:useful-tools-from-the-numpy-and-scipy-modules}
The \code{numpy} and \code{scipy} modules offer a multitude of functions and tools.  They
both have their own documentation.  Here we simply highlight a few functions that
could be used for common things an astronomer might want to do.  The idea is to
get the reader started in her exploration of \code{numpy} and \code{scipy}.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{numpy.ma} \PYG{k+kn}{as} \PYG{n+nn}{ma}
\PYG{k+kn}{import} \PYG{n+nn}{scipy.ndimage.filters} \PYG{k+kn}{as} \PYG{n+nn}{filters}
\PYG{k+kn}{from} \PYG{n+nn}{numdisplay} \PYG{k+kn}{import} \PYG{n}{display}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{N20110313S0188.fits}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}

\PYG{c}{\PYGZsh{} The shape of the ndarray stored in data is given by .shape}
\PYG{c}{\PYGZsh{} The first number is NAXIS2, the second number is NAXIS1.}
\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}

\PYG{c}{\PYGZsh{} Calculate the mean and median of the entire array.}
\PYG{c}{\PYGZsh{} Note how the way mean and median are called differently.}
\PYG{n}{data}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{median}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}

\PYG{c}{\PYGZsh{} If the desired operation is a clipped mean, ie. rejecting}
\PYG{c}{\PYGZsh{} values before calculating the mean, the numpy.ma module}
\PYG{c}{\PYGZsh{} can be used to mask the data.  Let's try a clipped mean}
\PYG{c}{\PYGZsh{} at -3 and +3 times the standard deviation}

\PYG{c}{\PYGZsh{} ma.masked\PYGZus{}outside() with mask out anything outside +/- 3*stddev of the mean.}
\PYG{c}{\PYGZsh{} mask\PYGZus{}extreme contains the "mask" returned by masked\PYGZus{}outside()}
\PYG{n}{stddev} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{mean} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{mask\PYGZus{}extreme} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{masked\PYGZus{}outside}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{mean}\PYG{o}{-}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{stddev}\PYG{p}{,} \PYG{n}{mean}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{stddev}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mask}

\PYG{c}{\PYGZsh{} ma.array() applies the mask to data.}
\PYG{c}{\PYGZsh{} The compressed() method converts the masked data into a ndarray on}
\PYG{c}{\PYGZsh{} which we can run .mean().}
\PYG{n}{clipped\PYGZus{}mean} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{mask}\PYG{o}{=}\PYG{n}{mask\PYGZus{}extreme}\PYG{p}{)}\PYG{o}{.}\PYG{n}{compressed}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Another common image operation is the filtering of an image.}
\PYG{c}{\PYGZsh{} To gaussian filter an image, use scipy.ndimage.filters.gaussian\PYGZus{}filter.}
\PYG{c}{\PYGZsh{} The filters module offers several other functions for image processing,}
\PYG{c}{\PYGZsh{} see help(filters)}
\PYG{n}{conv\PYGZus{}data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{size}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
\PYG{n}{sigma} \PYG{o}{=} \PYG{l+m+mf}{10.}
\PYG{n}{filters}\PYG{o}{.}\PYG{n}{gaussian\PYGZus{}filter}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{sigma}\PYG{p}{,} \PYG{n}{output}\PYG{o}{=}\PYG{n}{conv\PYGZus{}data}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{zscale}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{conv\PYGZus{}data}\PYG{p}{,} \PYG{n}{zscale}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}

\PYG{c}{\PYGZsh{} If you wanted to put this convoled data back in the AstroData}
\PYG{c}{\PYGZsh{} object you would do:}
\PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{conv\PYGZus{}data}
\end{Verbatim}


\section{Using the AstroData Data Quality Plane}
\label{data:using-the-astrodata-data-quality-plane}
TO BE WRITTEN -\textgreater{} transform DQ plane into a numpy mask and do statistics


\section{Manipulate Data Sections}
\label{data:manipulate-data-sections}
Sections of the data array can be accessed and processed.  It is important to
note here that when indexing a numpy array, the left most number refers to the
highest dimension's axis.  Also important, is to remember that the numpy arrays
are 0-indexed, not 1-indexed like in Fortran and IRAF.  For example, in a 2-D
numpy array, the pixel position (x,y) = (50,75) would be accessed as data{[}74,49{]}.

Here are some examples using data sections.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{N20110313S0188.fits}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}

\PYG{c}{\PYGZsh{} Let's get statistics for a 25x25 pixel-wide box centered on pixel 50,75.}
\PYG{n}{mean} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{62}\PYG{p}{:}\PYG{l+m+mi}{87}\PYG{p}{,}\PYG{l+m+mi}{37}\PYG{p}{:}\PYG{l+m+mi}{62}\PYG{p}{]}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{median} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{median}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{62}\PYG{p}{:}\PYG{l+m+mi}{87}\PYG{p}{,}\PYG{l+m+mi}{37}\PYG{p}{:}\PYG{l+m+mi}{62}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{stddev} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{62}\PYG{p}{:}\PYG{l+m+mi}{87}\PYG{p}{,}\PYG{l+m+mi}{37}\PYG{p}{:}\PYG{l+m+mi}{62}\PYG{p}{]}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{minimum} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{62}\PYG{p}{:}\PYG{l+m+mi}{87}\PYG{p}{,}\PYG{l+m+mi}{37}\PYG{p}{:}\PYG{l+m+mi}{62}\PYG{p}{]}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{maximum} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{62}\PYG{p}{:}\PYG{l+m+mi}{87}\PYG{p}{,}\PYG{l+m+mi}{37}\PYG{p}{:}\PYG{l+m+mi}{62}\PYG{p}{]}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{Mean      Median Stddev       Min    Max}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{mean}\PYG{p}{,} \PYG{n}{median}\PYG{p}{,} \PYG{n}{stddev}\PYG{p}{,} \PYG{n}{minimum}\PYG{p}{,} \PYG{n}{maximum}
\end{Verbatim}

Now let us apply our knownledge so far to do a quick overscan subtraction.
In this example, we make use of Descriptors, astrodata arithmetic
functions, data sections, numpy 0-based arrays, and numpy statistics function mean().:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Get the (EXTNAME,EXTVER)-keyed dictionary for the overscan section and}
\PYG{c}{\PYGZsh{} the data section.}
\PYG{n}{oversec\PYGZus{}descriptor} \PYG{o}{=} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{overscan\PYGZus{}section}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{as\PYGZus{}dict}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{datasec\PYGZus{}descriptor} \PYG{o}{=} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{data\PYGZus{}section}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{as\PYGZus{}dict}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Loop through the extensions.}
\PYG{k}{for} \PYG{n}{ext} \PYG{o+ow}{in} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{:}
    \PYG{n}{extnamever} \PYG{o}{=} \PYG{p}{(}\PYG{n}{ext}\PYG{o}{.}\PYG{n}{extname}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{ext}\PYG{o}{.}\PYG{n}{extver}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n}{x2}\PYG{p}{,} \PYG{n}{y1}\PYG{p}{,} \PYG{n}{y2}\PYG{p}{)} \PYG{o}{=} \PYG{n}{oversec\PYGZus{}descriptor}\PYG{p}{[}\PYG{n}{extnamever}\PYG{p}{]}
    \PYG{p}{(}\PYG{n}{dx1}\PYG{p}{,} \PYG{n}{dx2}\PYG{p}{,} \PYG{n}{dy1}\PYG{p}{,} \PYG{n}{dy2}\PYG{p}{)} \PYG{o}{=} \PYG{n}{datasec\PYGZus{}descriptor}\PYG{p}{[}\PYG{n}{extnamever}\PYG{p}{]}

    \PYG{c}{\PYGZsh{} Measure and subtract the overscan level}
    \PYG{n}{mean\PYGZus{}overscan} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{n}{extnamever}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{y1}\PYG{p}{:}\PYG{n}{y2}\PYG{p}{,}\PYG{n}{x1}\PYG{p}{:}\PYG{n}{x2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{ad}\PYG{p}{[}\PYG{n}{extnamever}\PYG{p}{]}\PYG{o}{.}\PYG{n}{sub}\PYG{p}{(}\PYG{n}{mean\PYGZus{}overscan}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} Trim the data to remove the overscan section and keep only}
    \PYG{c}{\PYGZsh{} the data section.}
    \PYG{n}{ad}\PYG{p}{[}\PYG{n}{extnamever}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{n}{extnamever}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{dy1}\PYG{p}{:}\PYG{n}{dy2}\PYG{p}{,}\PYG{n}{dx1}\PYG{p}{:}\PYG{n}{dx2}\PYG{p}{]}
\end{Verbatim}


\section{Work on Data Cubes}
\label{data:work-on-data-cubes}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{k+kn}{from} \PYG{n+nn}{numdisplay} \PYG{k+kn}{import} \PYG{n}{display}
\PYG{k+kn}{from} \PYG{n+nn}{pylab} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{adcube} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{gmosifu\PYGZus{}cube.fits}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{adcube}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} The pixel data is a 3-dimensional numpy array with wavelength is axis 0, and}
\PYG{c}{\PYGZsh{} x,y positions in axis 2 and 1, respectively.  (In the FITS file, wavelength}
\PYG{c}{\PYGZsh{} is in axis 3, and x, y are in axis 1 and 2, respectively.)}
\PYG{n}{adcube}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}

\PYG{c}{\PYGZsh{} To sum along the wavelength axis}
\PYG{n}{sum\PYGZus{}image} \PYG{o}{=} \PYG{n}{adcube}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sum\PYGZus{}image}\PYG{p}{,} \PYG{n}{zscale}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}

\PYG{c}{\PYGZsh{} To plot a 1-D representation of the wavelength axis at pixel position (7,30)}
\PYG{n}{plot}\PYG{p}{(}\PYG{n}{adcube}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{29}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} To plot the same thing using the wavelength values for the x axis of the plot}
\PYG{c}{\PYGZsh{} one needs to use the WCS to calculate the pixel to wavelength conversion.}
\PYG{n}{crval3} \PYG{o}{=} \PYG{n}{adcube}\PYG{o}{.}\PYG{n}{get\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{CRVAL3}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{cdelt3} \PYG{o}{=} \PYG{n}{adcube}\PYG{o}{.}\PYG{n}{get\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{CDELT3}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{spec\PYGZus{}length} \PYG{o}{=} \PYG{n}{adcube}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{29}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{o}{.}\PYG{n}{size}
\PYG{n}{wavelength} \PYG{o}{=} \PYG{n}{crval3} \PYG{o}{+} \PYG{n}{arange}\PYG{p}{(}\PYG{n}{spec\PYGZus{}length}\PYG{p}{)}\PYG{o}{*}\PYG{n}{cdelt3}
\PYG{n}{plot}\PYG{p}{(}\PYG{n}{wavelength}\PYG{p}{,} \PYG{n}{adcube}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{29}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\section{Plot Data}
\label{data:plot-data}
In Python, the main tool to create plots is \code{matplotlib}.  We have used it in the
previous section on data cubes.  Here we do not aimed at covering all of \code{matplotlib};
the reader should refer to that package's documentation.  Rather we will give a few
examples that might be of use for quick inspection of the data.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{k+kn}{from} \PYG{n+nn}{pylab} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{adimg} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{N20110313S0188.fits}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{adspec} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{estgsS20080220S0078.fits}\PYG{l+s}{'}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Line plot from image.  Row \PYGZsh{}1044.}
\PYG{n}{line\PYGZus{}index} \PYG{o}{=} \PYG{l+m+mi}{1043}
\PYG{n}{line} \PYG{o}{=} \PYG{n}{adimg}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{line\PYGZus{}index}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]}
\PYG{n}{plot}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Column plot from image, averaging across 11 pixels around column \PYGZsh{}327.}
\PYG{n}{col\PYGZus{}index} \PYG{o}{=} \PYG{l+m+mi}{326}
\PYG{n}{width} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{col\PYGZus{}section} \PYG{o}{=} \PYG{n}{adimg}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{col\PYGZus{}index}\PYG{o}{-}\PYG{n}{width}\PYG{p}{:}\PYG{n}{col\PYGZus{}index}\PYG{o}{+}\PYG{n}{width}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{column} \PYG{o}{=} \PYG{n}{col\PYGZus{}section}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{plot}\PYG{p}{(}\PYG{n}{column}\PYG{p}{)}
\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Contour plot for section}
\PYG{n}{galaxy} \PYG{o}{=} \PYG{n}{adimg}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{1045}\PYG{p}{:}\PYG{l+m+mi}{1085}\PYG{p}{,}\PYG{l+m+mi}{695}\PYG{p}{:}\PYG{l+m+mi}{735}\PYG{p}{]}
\PYG{n}{contour}\PYG{p}{(}\PYG{n}{galaxy}\PYG{p}{)}
\PYG{n}{axis}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{equal}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Spectrum in pixel}
\PYG{n}{plot}\PYG{p}{(}\PYG{n}{adspec}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}
\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Spectrum in wavelength (CRPIX1 = 1)}
\PYG{n}{crpix1} \PYG{o}{=} \PYG{n}{adspec}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{get\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{CRPIX1}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{crval1} \PYG{o}{=} \PYG{n}{adspec}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{get\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{CRVAL1}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{cdelt1} \PYG{o}{=} \PYG{n}{adspec}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{get\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{CDELT1}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{length} \PYG{o}{=} \PYG{n}{adspec}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{get\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{NAXIS1}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{wavelengths} \PYG{o}{=} \PYG{n}{crval1} \PYG{o}{+} \PYG{p}{(}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{length}\PYG{p}{)}\PYG{o}{-}\PYG{n}{crpix1}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{cdelt1}
\PYG{n}{plot}\PYG{p}{(}\PYG{n}{wavelengths}\PYG{p}{,} \PYG{n}{adspec}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SCI}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}
\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\chapter{Table Data}
\label{tables:table-data}\label{tables::doc}
\code{Astrodata} does not provide any special wrappers for FITS Table Data.  But
since \code{astrodata} is built on top of \code{pyfits}, the standard \code{pyfits}
table functions can be used.  The reader should refer to the \code{pyfits} documentation
for complete details.  Here we show a few useful examples of basic usage.


\section{Read from a FITS Table}
\label{tables:read-from-a-fits-table}
A FITS table is stored in a MEF file as a \code{BinTableHDU}.  The table data is retrieved from
the \code{AstroData} object with the same \code{.data} attribute as for pixel extension, but for
FITS tables \code{.data} returns a \code{FITS\_rec}, which is a \code{pyfits} class.  Here is how to
get information out of a FITS table.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}

\PYG{n}{adspec} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{estgsS20080220S0078.fits}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{adspec}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}
\PYG{c}{\PYGZsh{} The first extension in that file is a FITS table with {}`{}`EXTNAME{}`{}` MDF, and {}`{}`EXTVER{}`{}` 1.}
\PYG{c}{\PYGZsh{} MDF stands for "Mask Definition File".  In Gemini data, those are used in the data reduction}
\PYG{c}{\PYGZsh{} to identify, to first order, where spectra fall on the detector.}

\PYG{c}{\PYGZsh{} Let's get the table data out of the AstroData object}
\PYG{n}{table} \PYG{o}{=} \PYG{n}{adspec}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{MDF}\PYG{l+s}{'}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}

\PYG{c}{\PYGZsh{} Get the column names with 'names' or more details with 'columns'}
\PYG{n}{table}\PYG{o}{.}\PYG{n}{names}
\PYG{n}{table}\PYG{o}{.}\PYG{n}{columns}

\PYG{c}{\PYGZsh{} Get all the data for a column}
\PYG{n}{x\PYGZus{}ccd\PYGZus{}values} \PYG{o}{=} \PYG{n}{table}\PYG{o}{.}\PYG{n}{field}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{x\PYGZus{}ccd}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{third\PYGZus{}col} \PYG{o}{=} \PYG{n}{table}\PYG{o}{.}\PYG{n}{field}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Print the table content}
\PYG{k}{print} \PYG{n}{table}

\PYG{c}{\PYGZsh{} Print the first 2 rows}
\PYG{k}{print} \PYG{n}{table}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}

\PYG{c}{\PYGZsh{} Select rows based on some criterion}
\PYG{n}{select\PYGZus{}table} \PYG{o}{=} \PYG{n}{table}\PYG{p}{[}\PYG{n}{table}\PYG{o}{.}\PYG{n}{field}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{y\PYGZus{}ccd}\PYG{l+s}{'}\PYG{p}{)} \PYG{o}{\textgreater{}} \PYG{l+m+mf}{2000.}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{select\PYGZus{}table}
\end{Verbatim}


\section{Create a FITS Table}
\label{tables:create-a-fits-table}
Creating a FITS table is mostly a matter of creating the columns, name and data.
The name is a string, the data is stored in a \code{numpy} array.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{k+kn}{import} \PYG{n+nn}{pyfits} \PYG{k+kn}{as} \PYG{n+nn}{pf}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{c}{\PYGZsh{} Create the input data}
\PYG{n}{snr\PYGZus{}id} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{S001}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{S002}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{S003}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{feii} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{780.}\PYG{p}{,}\PYG{l+m+mf}{78.}\PYG{p}{,}\PYG{l+m+mf}{179.}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{pabeta} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{740.}\PYG{p}{,}\PYG{l+m+mf}{307.}\PYG{p}{,}\PYG{l+m+mf}{220.}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ratio} \PYG{o}{=} \PYG{n}{pabeta}\PYG{o}{/}\PYG{n}{feii}

\PYG{c}{\PYGZsh{} Create the columns}
\PYG{n}{col1} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{Column}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{SNR\PYGZus{}ID}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{format}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{4A}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{array}\PYG{o}{=}\PYG{n}{snr\PYGZus{}id}\PYG{p}{)}
\PYG{n}{col2} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{Column}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{ratio}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{format}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{E}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{array}\PYG{o}{=}\PYG{n}{ratio}\PYG{p}{)}
\PYG{n}{col3} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{Column}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{feii}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{format}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{E}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{array}\PYG{o}{=}\PYG{n}{feii}\PYG{p}{)}
\PYG{n}{col4} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{Column}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{pabeta}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{format}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{E}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{array}\PYG{o}{=}\PYG{n}{pabeta}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Assemble the columns}
\PYG{n}{cols} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{ColDefs}\PYG{p}{(}\PYG{p}{[}\PYG{n}{col1}\PYG{p}{,}\PYG{n}{col2}\PYG{p}{,}\PYG{n}{col3}\PYG{p}{,}\PYG{n}{col4}\PYG{p}{]}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Create the table HDU}
\PYG{n}{tablehdu} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{new\PYGZus{}table}\PYG{p}{(}\PYG{n}{cols}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Create an AstroData object to contain the table}
\PYG{c}{\PYGZsh{} and write to disk.}
\PYG{n}{new\PYGZus{}ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{n}{tablehdu}\PYG{p}{)}
\PYG{n}{new\PYGZus{}ad}\PYG{o}{.}\PYG{n}{rename\PYGZus{}ext}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{MYTABLE}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{new\PYGZus{}ad}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{mytable.fits}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

A new FITS table can also be appended to an already existing AstroData object with
the \code{.append()} function.


\section{Operate on a FITS Table}
\label{tables:operate-on-a-fits-table}
The \code{pyfits} manual is the recommended source for a more complete documentation
on working on FITS table with Python.  Here are a few examples of what one can
modify a FITS table.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{k+kn}{import} \PYG{n+nn}{pyfits} \PYG{k+kn}{as} \PYG{n+nn}{pf}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{c}{\PYGZsh{} Let us first create tables to play with}
\PYG{n}{snr\PYGZus{}id} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{S001}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{S002}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{S003}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{feii} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{780.}\PYG{p}{,}\PYG{l+m+mf}{78.}\PYG{p}{,}\PYG{l+m+mf}{179.}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{pabeta} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{740.}\PYG{p}{,}\PYG{l+m+mf}{307.}\PYG{p}{,}\PYG{l+m+mf}{220.}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ratio} \PYG{o}{=} \PYG{n}{pabeta}\PYG{o}{/}\PYG{n}{feii}
\PYG{n}{col1} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{Column}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{SNR\PYGZus{}ID}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{format}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{4A}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{array}\PYG{o}{=}\PYG{n}{snr\PYGZus{}id}\PYG{p}{)}
\PYG{n}{col2} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{Column}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{ratio}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{format}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{E}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{array}\PYG{o}{=}\PYG{n}{ratio}\PYG{p}{)}
\PYG{n}{col3} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{Column}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{feii}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{format}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{E}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{array}\PYG{o}{=}\PYG{n}{feii}\PYG{p}{)}
\PYG{n}{col4} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{Column}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{pabeta}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{format}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{E}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{array}\PYG{o}{=}\PYG{n}{pabeta}\PYG{p}{)}
\PYG{n}{cols\PYGZus{}t1} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{ColDefs}\PYG{p}{(}\PYG{p}{[}\PYG{n}{col1}\PYG{p}{,}\PYG{n}{col3}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{cols\PYGZus{}t2} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{ColDefs}\PYG{p}{(}\PYG{p}{[}\PYG{n}{col1}\PYG{p}{,}\PYG{n}{col4}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{cols\PYGZus{}t3} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{ColDefs}\PYG{p}{(}\PYG{p}{[}\PYG{n}{col2}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{table1} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{new\PYGZus{}table}\PYG{p}{(}\PYG{n}{cols\PYGZus{}t1}\PYG{p}{)}
\PYG{n}{table2} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{new\PYGZus{}table}\PYG{p}{(}\PYG{n}{cols\PYGZus{}t2}\PYG{p}{)}
\PYG{n}{table3} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{new\PYGZus{}table}\PYG{p}{(}\PYG{n}{cols\PYGZus{}t3}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Merge tables}
\PYG{c}{\PYGZsh{}   WARNING: The input tables must NOT share any common field names.}
\PYG{c}{\PYGZsh{}      For example, table1 and table2 cannot be merged this way since they share col1.}
\PYG{n}{merged\PYGZus{}cols} \PYG{o}{=} \PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns} \PYG{o}{+} \PYG{n}{table3}\PYG{o}{.}\PYG{n}{columns}
\PYG{n}{merged\PYGZus{}table} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{new\PYGZus{}table}\PYG{p}{(}\PYG{n}{merged\PYGZus{}cols}\PYG{p}{)}
\PYG{n}{merged\PYGZus{}table}\PYG{o}{.}\PYG{n}{columns}\PYG{o}{.}\PYG{n}{names}  \PYG{c}{\PYGZsh{} or merged\PYGZus{}table.data.names}
\PYG{k}{print} \PYG{n}{merged\PYGZus{}table}\PYG{o}{.}\PYG{n}{data}

\PYG{c}{\PYGZsh{} Add/Delete column}
\PYG{c}{\PYGZsh{}   To "add" the 'pabeta' column from table2 to table1}
\PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns}\PYG{o}{.}\PYG{n}{add\PYGZus{}col}\PYG{p}{(}\PYG{n}{table2}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{[}\PYG{n}{table2}\PYG{o}{.}\PYG{n}{columns}\PYG{o}{.}\PYG{n}{names}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{pabeta}\PYG{l+s}{'}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{table1} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{new\PYGZus{}table}\PYG{p}{(}\PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{)}
\PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns}\PYG{o}{.}\PYG{n}{names}
\PYG{k}{print} \PYG{n}{table1}\PYG{o}{.}\PYG{n}{data}

\PYG{c}{\PYGZsh{}   To "delete" the 'pabeta' column from this new table1}
\PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns}\PYG{o}{.}\PYG{n}{del\PYGZus{}col}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{pabeta}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{table1} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{new\PYGZus{}table}\PYG{p}{(}\PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{)}
\PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns}\PYG{o}{.}\PYG{n}{names}
\PYG{k}{print} \PYG{n}{table1}\PYG{o}{.}\PYG{n}{data}

\PYG{c}{\PYGZsh{} Insert column}
\PYG{c}{\PYGZsh{}   To insert a column, one has to extract the columns}
\PYG{c}{\PYGZsh{}   and reorganize them into a new table.}
\PYG{c}{\PYGZsh{}   Insert the first, and only column, in table3, between the first and second}
\PYG{c}{\PYGZsh{}   column in table1}
\PYG{n}{t1\PYGZus{}col1} \PYG{o}{=} \PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{t1\PYGZus{}col2} \PYG{o}{=} \PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{t3\PYGZus{}col1} \PYG{o}{=} \PYG{n}{table3}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{table1} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{new\PYGZus{}table}\PYG{p}{(}\PYG{p}{[}\PYG{n}{t1\PYGZus{}col1}\PYG{p}{,}\PYG{n}{t3\PYGZus{}col1}\PYG{p}{,}\PYG{n}{t1\PYGZus{}col2}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns}\PYG{o}{.}\PYG{n}{names}
\PYG{k}{print} \PYG{n}{table1}\PYG{o}{.}\PYG{n}{data}

\PYG{c}{\PYGZsh{} Change the name of a column}
\PYG{c}{\PYGZsh{}   WARNING: There is method .change\PYGZus{}name but it does not seem to be}
\PYG{c}{\PYGZsh{}            working properly.}
\PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{[}\PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns}\PYG{o}{.}\PYG{n}{names}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{feii}\PYG{l+s}{'}\PYG{p}{)}\PYG{p}{]}\PYG{o}{.}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{ironII}\PYG{l+s}{'}
\PYG{n}{table1} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{new\PYGZus{}table}\PYG{p}{(}\PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Add/Delete row}
\PYG{c}{\PYGZsh{}  Adding and deleting rows requires the creation of a new table}
\PYG{c}{\PYGZsh{}  of the correct, new size.}
\PYG{c}{\PYGZsh{}}
\PYG{c}{\PYGZsh{}  Add 2 new entries to table2.  Only 'SNR\PYGZus{}ID' and 'pabeta' will be}
\PYG{c}{\PYGZsh{}  added as those are the columns already present in table2.}
\PYG{n}{nb\PYGZus{}new\PYGZus{}entries} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{new\PYGZus{}entries} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{'}\PYG{l+s}{SNR\PYGZus{}ID}\PYG{l+s}{'}\PYG{p}{:} \PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{S004}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{S005}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{,}
              \PYG{l+s}{'}\PYG{l+s}{ratio}\PYG{l+s}{'} \PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{1.12}\PYG{p}{,} \PYG{l+m+mf}{0.72}\PYG{p}{]}\PYG{p}{,}
              \PYG{l+s}{'}\PYG{l+s}{feii}\PYG{l+s}{'}  \PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{77.}\PYG{p}{,} \PYG{l+m+mf}{87.}\PYG{p}{]}\PYG{p}{,}
              \PYG{l+s}{'}\PYG{l+s}{pabeta}\PYG{l+s}{'}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{69.}\PYG{p}{,} \PYG{l+m+mf}{122.}\PYG{p}{]}
              \PYG{p}{\PYGZcb{}}
\PYG{n}{nrowst2} \PYG{o}{=} \PYG{n}{table2}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{large\PYGZus{}table} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{new\PYGZus{}table}\PYG{p}{(}\PYG{n}{table2}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{,} \PYG{n}{nrows}\PYG{o}{=}\PYG{n}{nrowst2}\PYG{o}{+}\PYG{n}{nb\PYGZus{}new\PYGZus{}entries}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{name} \PYG{o+ow}{in} \PYG{n}{table2}\PYG{o}{.}\PYG{n}{columns}\PYG{o}{.}\PYG{n}{names}\PYG{p}{:}
    \PYG{n}{large\PYGZus{}table}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{field}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}\PYG{p}{[}\PYG{n}{nrowst2}\PYG{p}{:}\PYG{p}{]}\PYG{o}{=}\PYG{n}{new\PYGZus{}entries}\PYG{p}{[}\PYG{n}{name}\PYG{p}{]}
\PYG{n}{table2} \PYG{o}{=} \PYG{n}{large\PYGZus{}table}

\PYG{c}{\PYGZsh{} Delete the last 2 entries from table2}
\PYG{n}{nb\PYGZus{}bad\PYGZus{}entries} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{nrowst2} \PYG{o}{=} \PYG{n}{table2}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{small\PYGZus{}table} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{new\PYGZus{}table}\PYG{p}{(}\PYG{n}{table2}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{,} \PYG{n}{nrows}\PYG{o}{=}\PYG{n}{nrowst2}\PYG{o}{-}\PYG{n}{nb\PYGZus{}bad\PYGZus{}entries}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{name} \PYG{o+ow}{in} \PYG{n}{table2}\PYG{o}{.}\PYG{n}{columns}\PYG{o}{.}\PYG{n}{names}\PYG{p}{:}
    \PYG{n}{small\PYGZus{}table}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{field}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}\PYG{o}{=}\PYG{n}{table2}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{field}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{o}{-}\PYG{n}{nb\PYGZus{}bad\PYGZus{}entries}\PYG{p}{]}
\PYG{n}{table2} \PYG{o}{=} \PYG{n}{small\PYGZus{}table}

\PYG{c}{\PYGZsh{} Change the 'pabeta' value for source S002 in table2}
\PYG{n}{rowindex} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{table2}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{field}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{SNR\PYGZus{}ID}\PYG{l+s}{'}\PYG{p}{)} \PYG{o}{==} \PYG{l+s}{'}\PYG{l+s}{S002}\PYG{l+s}{'}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{table2}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{field}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{pabeta}\PYG{l+s}{'}\PYG{p}{)}\PYG{p}{[}\PYG{n}{rowindex}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{888.}
\end{Verbatim}


\chapter{Log Utility}
\label{logging::doc}\label{logging:log-utility}

\section{The Astrodata Log Utility}
\label{logging:the-astrodata-log-utility}
Astrodata uses a logging utility based on the Python logging facility.
astrodata/adutils/logutils.py
creates logfile, default name reduce.log
\begin{description}
\item[{config() method}] \leavevmode
mode: standard, stream, null, debug
consolve\_lvl: controls the console logging level
file\_name: logfile name (default=reduce.log)
stomp:  clobber

\end{description}

get\_logger()

update\_indent(): control indenting during recipe/primitive execution.

logger mode standard: default console-\textgreater{} stdinfo, default to file-\textgreater{} fullinfo


\section{Writing to Log}
\label{logging:writing-to-log}
Using the logging facility involves \emph{getting} the logger, \emph{configuring} the logger,

\code{log.\textless{}loglevel\textgreater{}(\textless{}message\_to\_log\textgreater{})}

default name: reduce.log

\begin{Verbatim}[commandchars=\\\{\}]
from astrodata.adutils import logutils

log = logutils.get\_logger(\_\_name\_\_)

??
log = self.log
self.log.stdinfo()
\end{Verbatim}

In primitives, call logger ``once at the top''


\section{Log Levels}
\label{logging:log-levels}
Several log levels are supported, some are directly from the Python logging facility,
others are defined in Astrodata.  Here are definitions of the log levels and usage
examples.
\begin{description}
\item[{critical}] \leavevmode
A serious error, indicating that the program itself may be unable to
continue running. For example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{try}\PYG{p}{:}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{k}{except}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} Log the message from the exception}
    \PYG{n}{log}\PYG{o}{.}\PYG{n}{critical}\PYG{p}{(}\PYG{n+nb}{repr}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{exc\PYGZus{}info}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} or simply}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{log}\PYG{o}{.}\PYG{n}{critical}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Something really bad happened.  Exiting now.}\PYG{l+s}{"}\PYG{p}{)}
\end{Verbatim}

\item[{error}] \leavevmode
Due to a serious problem, the software has not been able to perform some function.
The error does not necessarily prevent the program from continuing.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{log}\PYG{o}{.}\PYG{n}{error}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{An error occurred while trying to calculate the }\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s}{           nbiascontam, using default value = 4}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\item[{warning}] \leavevmode
An indication that something unexpected happened, or indicative of some problem
in the near future. The software is still working as expected, but might be using
some default or recovery settings.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{log}\PYG{o}{.}\PYG{n}{warning}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{A [DQ,}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{] extension already exists in }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{"} \PYG{o}{\PYGZpc{}}
            \PYG{p}{(}\PYG{n}{extver}\PYG{p}{,} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\item[{status}] \leavevmode
Start and end processing information, number of files, name of the input or output
files.  In other words, ``What's happening? What's being processed?''

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{log}\PYG{o}{.}\PYG{n}{status}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{List for stack id=}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{"} \PYG{o}{\PYGZpc{}} \PYG{n}{sid}\PYG{p}{)}
\PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{stacklist}\PYG{p}{)} \PYG{o}{\textgreater{}} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{f} \PYG{o+ow}{in} \PYG{n}{stacklist}\PYG{p}{:}
        \PYG{n}{log}\PYG{o}{.}\PYG{n}{status}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{    }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{"} \PYG{o}{\PYGZpc{}} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{basename}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n}{log}\PYG{o}{.}\PYG{n}{status}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{No datasets in list}\PYG{l+s}{"}\PYG{p}{)}
\end{Verbatim}

\item[{stdinfo}] \leavevmode
Scientific information like seeing measurements, statistics, etc. or what
is scientifically being done to the data.  This is information that an
astronomer might want to see displayed on the screen.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{log}\PYG{o}{.}\PYG{n}{stdinfo}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Adding the read noise component of the variance}\PYG{l+s}{"}\PYG{p}{)}
\PYG{n}{log}\PYG{o}{.}\PYG{n}{stdinfo}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{RA: }\PYG{l+s+si}{\PYGZpc{}.2f}\PYG{l+s}{ +- }\PYG{l+s+si}{\PYGZpc{}.2f}\PYG{l+s}{    Dec: }\PYG{l+s+si}{\PYGZpc{}.2f}\PYG{l+s}{ +- }\PYG{l+s+si}{\PYGZpc{}.2f}\PYG{l+s}{   arcsec}\PYG{l+s}{"} \PYG{o}{\PYGZpc{}}
             \PYG{p}{(}\PYG{n}{ra\PYGZus{}mean}\PYG{p}{,} \PYG{n}{ra\PYGZus{}sigma}\PYG{p}{,} \PYG{n}{dec\PYGZus{}mean}\PYG{p}{,} \PYG{n}{dec\PYGZus{}sigma}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\item[{info}] \leavevmode
Confirmation that things are working as expected.  The information here is
more programmatical than scientific.

\item[{fullinfo}] \leavevmode
Detailed information on the processing, like input parameters, header
changes.  Useful information for a log file but not necessary for standard
output (screen output).

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{log}\PYG{o}{.}\PYG{n}{fullinfo}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Tiling extensions together to get statistics from CCD2}\PYG{l+s}{"}\PYG{p}{)}
\PYG{n}{log}\PYG{o}{.}\PYG{n}{fullinfo}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Using data section [}\PYG{l+s+si}{\PYGZpc{}i}\PYG{l+s}{:}\PYG{l+s+si}{\PYGZpc{}i}\PYG{l+s}{,}\PYG{l+s+si}{\PYGZpc{}i}\PYG{l+s}{:}\PYG{l+s+si}{\PYGZpc{}i}\PYG{l+s}{] from CCD2 for statistics}\PYG{l+s}{"} \PYG{o}{\PYGZpc{}}
              \PYG{p}{(}\PYG{n}{xborder}\PYG{p}{,}\PYG{n}{sci\PYGZus{}data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{-}\PYG{n}{xborder}\PYG{p}{,}
               \PYG{n}{yborder}\PYG{p}{,}\PYG{n}{sci\PYGZus{}data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{-}\PYG{n}{yborder}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\item[{debug}] \leavevmode
Very detailed engineering information for used in debugging.
For example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{log}\PYG{o}{.}\PYG{n}{debug}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{SplotETI \PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{l+s}{"}\PYG{p}{)}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{log}\PYG{o}{.}\PYG{n}{debug}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{SplotETI.execute()}\PYG{l+s}{"}\PYG{p}{)}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{log}\PYG{o}{.}\PYG{n}{debug}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{SplotETI.run()}\PYG{l+s}{"}\PYG{p}{)}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{log}\PYG{o}{.}\PYG{n}{debug}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{SplotETI.recover()}\PYG{l+s}{"}\PYG{p}{)}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{Verbatim}

\end{description}


\chapter{Dataset Validation}
\label{validation:dataset-validation}\label{validation::doc}

\section{File Structure Validation}
\label{validation:file-structure-validation}

\chapter{Advanced Topics}
\label{advanced:advanced-topics}\label{advanced::doc}

\section{Creating a New Configuration Module}
\label{advanced:creating-a-new-configuration-module}

\section{Adding Support for a New Instrument}
\label{advanced:adding-support-for-a-new-instrument}

\chapter{Other Topics}
\label{other:other-topics}\label{other::doc}

\chapter{List of Standard Descriptors}
\label{descriptors:list-of-standard-descriptors}\label{descriptors::doc}
(this should be an appendix)

List the descriptors that we have and give a definition.



\renewcommand{\indexname}{Index}
\printindex
\end{document}
