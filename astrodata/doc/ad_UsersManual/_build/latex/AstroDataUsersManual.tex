% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{appendix} \setcounter{tocdepth}{0}

\title{AstroData Users Manual}
\date{November 14, 2014}
\release{X1.0.1}
\author{Kathleen Labrie}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index-latex::doc}



\chapter{Introduction}
\label{intro:introduction}\label{intro:intro}\label{intro::doc}\label{intro:astrodata-user-s-manual}

\section{What is AstroData?}
\label{intro:what-is-astrodata}
The AstroData class is a tool to represent datasets stored in
Multi-Extension FITS (MEF) files. It provides uniform interfaces for
working on datasets from different instruments and their observational modes.
Configuration packages are used to describe the specific data characteristics,
layout, and to store type-specific implementations.  Once a MEF has been
opened with AstroData, the object it is assigned to knows essential information
about itself, like from which instrument this data comes from, how to access
the header information, etc.

Multi-extension FITS files are generalized as lists of header-data units
(HDU), with key-value pairs populating headers, and pixel values populating
data arrays. AstroData interprets a MEF as a single complex entity.  The
individual ``extensions'' within the MEF are available with normal Python list
(``{[}{]}'') syntax.

In order to identify types for the dataset and provide type-specific behavior,
AstroData relies on configuration packages.  A configuration package (eg.
\code{astrodata\_Gemini}) contains definitions for all instruments and modes. A
configuration package contains type definitions, meta-data functions,
information lookup tables, and any other code or information needed to handle
specific types of dataset.


\section{Installing AstroData}
\label{intro:installing-astrodata}\label{intro:install}
The \code{astrodata} package has several dependencies like \code{numpy}, \code{astropy}, and others.
The best way to get everything you need is to install Ureka, \href{http://ssb.stsci.edu/ureka/}{http://ssb.stsci.edu/ureka/}.

WARNING:  The Ureka installation script will not set up IRAF for you. You need to do
that yourself. Here's how:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} cd \PYGZti{}
\PYGZdl{} mkdir iraf
\PYGZdl{} cd iraf
\PYGZdl{} mkiraf
\PYGZhy{}\PYGZhy{} creating a new uparm directory
Terminal types: xgterm,xterm,gterm,vt640,vt100,etc.
Enter terminal type: xgterm
A new LOGIN.CL file has been created in the current directory.
You may wish to review and edit this file to change the defaults.
\end{Verbatim}

Once this is done, install \code{gemini\_python}.  The \code{astrodata} package is currently
distributed as part of the \code{gemini\_python} package.  The \code{gemini\_python} package,
\code{gemini\_python-X1.tar.gz}, can be obtained from the Gemini website:
\begin{quote}

\href{http://www.gemini.edu/sciops/data-and-results/processing-software}{http://www.gemini.edu/sciops/data-and-results/processing-software}
\end{quote}


\subsection{Recommended installation}
\label{intro:recommended-installation}
It is recommended to install the software in a location other than the standard python
location for modules (the default \code{site-packages}). This is also the only solution if
you do not have write permission to the default \code{site-packages}.  Here is how you
install the software somewhere other than the default location:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} python setup.py install \PYGZhy{}\PYGZhy{}prefix=/your/favorite/location
\end{Verbatim}

\code{/your/favorite/location} must already exist.  This command will install executable
scripts in a \code{bin} subdirectory, the documentation in a \code{share} subdirectory,
and the modules in a \code{lib/python2.7/site-packages} subdirectory.  The modules being
installed are \code{astrodata}, \code{astrodata\_FITS}, \code{astrodata\_Gemini}, and \code{gempy}.
In this manual, we will not use \code{gempy}.

Because you are not using the default location, you will need to add two paths to
your environment.  You might want to add the following to your .cshrc or .bash\_profile,
or equivalent shell configuration script.

For tcsh:

\begin{Verbatim}[commandchars=\\\{\}]
setenv PATH /your/favorite/location/bin:\PYGZdl{}\PYGZob{}PATH\PYGZcb{}
setenv PYTHONPATH /your/favorite/location/lib/python2.7/site\PYGZhy{}packages:\PYGZdl{}\PYGZob{}PYTHONPATH\PYGZcb{}
\end{Verbatim}

For bash:

\begin{Verbatim}[commandchars=\\\{\}]
export PATH=/your/favorite/location/bin:\PYGZdl{}\PYGZob{}PATH\PYGZcb{}
export PYTHONPATH=/your/favorite/location/lib/python2.7/site\PYGZhy{}packages:\PYGZdl{}\PYGZob{}PYTHONPATH\PYGZcb{}
\end{Verbatim}

If you added those lines to your shell configuration script, make sure your \code{source}
the file to activate the new setting.

For tcsh:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} source \PYGZti{}/.cshrc
\PYGZdl{} rehash
\end{Verbatim}

For bash:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} source \PYGZti{}/.bash\PYGZus{}profile
\end{Verbatim}


\subsection{Easier but more dangerous installation}
\label{intro:easier-but-more-dangerous-installation}
Assuming that you have installed Ureka and that you have write access to the Ureka
directory, this will install \code{astrodata} in the Ureka \code{site-packages} directory.
WARNING: While easier to install and configure, this will modify your Ureka
installation.

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} python setup.py install
\end{Verbatim}

This will also add executables to the Ureka \code{bin} directory and documentation to
the Ureka \code{share} directory.

With this installation scheme, there is no need to add paths to your environment.
However, it is a lot more complicated to remove the Gemini software in case of
problems, or if you just want to clean it out after evaluation.

In tcsh, you will need to run \code{rehash} to pick the new executables written to \code{bin}.


\subsection{Smoke test the installation}
\label{intro:smoke-test-the-installation}
Just to make there is nothing obviously wrong with the installation and configuration,
we recommend that you run the following smoke tests:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} which typewalk

Expected result: /your/favorite/location/bin/typewalk
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} python
\PYGZgt{}\PYGZgt{}\PYGZgt{} from astrodata import AstroData

Expected result: Just a python prompt and no error messages.
\end{Verbatim}


\section{AstroData Support}
\label{intro:astrodata-support}
This release of \code{astrodata} as part of \code{gemini\_python-X1} is an early release of what
we are working on.  It is not a fully supported product yet.  If you do have questions or
feedback, please use the Gemini Helpdesk but keep in mind that the ticket will be addressed
on a best-effort basis only.


\chapter{MEF Input/Output Operations and Extensions Manipulation}
\label{io:mef-input-output-operations-and-extensions-manipulation}\label{io::doc}\label{io:io}
In this section, we will show and discuss how to read and write to a
Multi-Extension FITS (MEF) file.

A MEF file is a Primary Header Unit (PHU) with a list of Header Data Units
(HDU), commonly referred to as extensions.  In AstroData, the extension
numbering is zero-indexed, the first extension is \code{myAstroData{[}0{]}} where
\code{myAstroData} is an open AstroData object.  If you are familiar with
IRAF, then keep in mind that in IRAF the extensions are 1-indexed.  For
example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} In IRAF
display myMEF[1]

\PYGZsh{} With AstroData
numdisplay.display(myAstroData[0].data)
\end{Verbatim}

The first data extension is 1 in IRAF, but it is 0 in AstroData.  All Python
arrays are zero-indexed, so AstroData was made compliant with modern practice.

\textbf{Try it yourself}

If you wish to follow along and try the commands yourself, download
the data package, go to the \code{playground} directory and copy over
the necessary files.

\begin{Verbatim}[commandchars=\\\{\}]
cd \PYGZlt{}path\PYGZgt{}/gemini\PYGZus{}python\PYGZus{}datapkg\PYGZhy{}X1/playground
cp ../data\PYGZus{}for\PYGZus{}ad\PYGZus{}user\PYGZus{}manual/N20110313S0188.fits .
cp ../data\PYGZus{}for\PYGZus{}ad\PYGZus{}user\PYGZus{}manual/N20110316S0321.fits .
cp ../data\PYGZus{}for\PYGZus{}ad\PYGZus{}user\PYGZus{}manual/N20111124S0203.fits .
\end{Verbatim}

Then launch the Python shell:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{python}
\end{Verbatim}


\section{Open and access existing MEF files}
\label{io:open-and-access-existing-mef-files}
An AstroData object can be created from the name of the file on disk, a URL,
or from PyFITS HDUList or HDU instance.  An existing MEF file can be opened as
an AstroData object in \code{readonly}, \code{update}, or \code{append} mode.
The default is \code{readonly}.

Here is a very simple example on how to open a file in \code{readonly} mode,
check the structure, and then close it:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N20111124S0203.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

The first line, imports the \code{AstroData} class.  The \code{info} method prints
to screen the list of extensions, their name, size, data type, etc.  Here's
what the example above will output:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Filename: N20111124S0203.fits
    Type: AstroData
    Mode: readonly

AD No.    Name          Type      MEF No.  Cards    Dimensions   Format
        hdulist       HDUList
        phu           PrimaryHDU    0       179
        phu.header    Header
[0]     (\PYGZsq{}SCI\PYGZsq{}, 1)    ImageHDU      1        71    (4608, 1056)  float32
           .header    Header
           .data      ndarray
[1]     (\PYGZsq{}SCI\PYGZsq{}, 2)    ImageHDU      2        71    (4608, 1056)  float32
           .header    Header
           .data      ndarray
[2]     (\PYGZsq{}SCI\PYGZsq{}, 3)    ImageHDU      3        71    (4608, 1056)  float32
           .header    Header
           .data      ndarray
[3]     (\PYGZsq{}SCI\PYGZsq{}, 4)    ImageHDU      4        71    (4608, 1056)  float32
           .header    Header
           .data      ndarray
[4]     (\PYGZsq{}SCI\PYGZsq{}, 5)    ImageHDU      5        71    (4608, 1056)  float32
           .header    Header
           .data      ndarray
[5]     (\PYGZsq{}SCI\PYGZsq{}, 6)    ImageHDU      6        71    (4608, 1056)  float32
           .header    Header
           .data      ndarray
\end{Verbatim}

To open the file in a mode other than \code{readonly}, one specifies the setting
of the \code{mode} argument:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N20111124S0203.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{update}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}


\subsection{Accessing the content of a MEF file}
\label{io:accessing-the-content-of-a-mef-file}
Conceivably one opens a file to access its content. Manipulations of the
pixel data and of the headers are covered in more details in later sections
({\hyperref[data:data]{\emph{Section 5 - Pixel Data}}} and
{\hyperref[headers:headers]{\emph{Section 4 - FITS Headers}}}, respectively). Here we show
a few very basic examples on how to access pixels and headers.

The pixel data in an AstroData object are stored as Numpy \code{ndarray}.
Any \code{ndarray} operations are valid.  We use Numpy's \code{average} function
in the example below.

The headers in an AstroData object are stored as PyFITS headers.  Any
PyFITS header operations are valid.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N20111124S0203.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{extension} \PYG{o+ow}{in} \PYG{n}{ad}\PYG{p}{:}
   \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Extension :}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{extension}\PYG{o}{.}\PYG{n}{extname}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{extension}\PYG{o}{.}\PYG{n}{extver}\PYG{p}{(}\PYG{p}{)}
   \PYG{c}{\PYGZsh{}}
   \PYG{c}{\PYGZsh{} Access the pixel data}
   \PYG{n}{data} \PYG{o}{=} \PYG{n}{extension}\PYG{o}{.}\PYG{n}{data}
   \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data is of : }\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
   \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{The pixel data type is: }\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{data}\PYG{o}{.}\PYG{n}{dtype}
   \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{The average of all the pixels is: }\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{average}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
   \PYG{c}{\PYGZsh{}}
   \PYG{c}{\PYGZsh{} Access the header}
   \PYG{n}{hdr} \PYG{o}{=} \PYG{n}{extension}\PYG{o}{.}\PYG{n}{header}
   \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{The value of NAXIS2 is: }\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{hdr}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{NAXIS2}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
   \PYG{k}{print}
\end{Verbatim}

\emph{(Python Beginner's Note 1: The {}`{}`\#{}`{}` on line 8 and 14 are not necessary to the
code but simplify
the cut and paste of the statements from the HTML page to the Python
shell, without affecting readability.)}

\emph{(Python Beginner's Note 2: In the Python shell, when you are done inputing the
statements of a loop,
you indicate so by typing return to create an empty line.  So, after you
have written the last {}`{}`print{}`{}` statement, type return on the {}`{}`...{}`{}` line,
this will launch the execution of the loop.)}

Now let us discuss the example.

As stated above, the pixel data are stored in \code{numpy.ndarray} objects.
Therefore, Numpy needs to be imported if any \code{numpy} operations is to
be run on the data.  This is done on Line 2, using the standard import
convention for Numpy.

On Line 6, the for-loop that will access the extension sequentially is defined.
Only the extensions are returned, the Primary Header Unit (PHU) is not
sent to the loop.  Access to the PHU is discussed in
{\hyperref[headers:headers]{\emph{Section 4 - FITS Headers}}}.

In an AstroData object, each extension is given, in memory if not on disk,
an extension name and an extension version.  Line 7 accesses that information.

On lines 10 to 13, the pixel data for the current extension is assigned to the
variable \code{data}, and then the array is explored a bit.

On lines 16 and 17, the header associated with the extension is assigned to
the variable \code{hdr}, and the value for the keyword \code{NAXIS2} is retrieved.

Note that for both \code{data} and \code{hdr}, the pixels or the headers are
NOT copied, the new variables simply point to the information stored in the
AstroData object.  If \code{data} or \code{hdr} are modified, the AstroData object
itself will be modified.

In the example above, a loop through the extensions is used.  To access a specific
extension by name, it is also possible to do something like this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Value of NAXIS2: }\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{header}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{NAXIS2}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

or if not using the names, using the positional number for the extension:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{header} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{header}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Extension name and version for extension 0: }\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYGZbs{}
   \PYG{n}{ad}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{extname}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ad}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{extver}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

Note that the extension positions are zero-indexed, \code{ad{[}0{]}} is not the
PHU, it is the first extension.


\section{Modify Existing MEF Files}
\label{io:modify-existing-mef-files}
To modify an existing MEF file, it must have been opened in the \code{update}
mode.  While a MEF opened in any mode can be modified at will in memory,
only an file opened in \code{update} (or \code{append}) mode can be overwritten
on disk.

Here we give examples on how to append an extension, how to insert an
extension, and how to remove an extension.  Finally we show
how to write the updated AstroData object to back disk as a MEF file.

Extension manipulations have been chosen for this discussion, but any other
type of modifications, eg. pixel arithmetics, header editing, etc. could
have been chosen instead.  Extension manipulations are a good introduction
to the structure and extension-naming convention of the AstroData MEF file
representation.


\subsection{Opening the files}
\label{io:opening-the-files}
For the extension manipulation examples of the next subsections, two files
are needed, one to serve as the main file to edit, and another from which
we can extract extension from for inserting or appending into the first.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N20110313S0188.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{update}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{adread} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N20110316S0321.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{readonly}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{new\PYGZus{}extension} \PYG{o}{=} \PYG{n}{adread}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{new\PYGZus{}extension}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

The first step is always to import the \code{AstroData} class (line 1).
On Line 3, the main dataset is open as an AstroData object in \code{update}
mode.  The other dataset is open in \code{readonly} mode (line 6).  Note that
the \code{readonly} is optional as this is the default mode.

An extension is ``extracted'' from the second dataset on line 7.  It is
important to realize that this does NOT create a copy of the extension.
The variable \code{new\_extension} simply \emph{points} to the data stored in \code{adread}.

The first dataset's structure is (from line 4, \code{ad.info()}):

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Filename: N20110313S0188.fits
    Type: AstroData
    Mode: readonly

AD No.    Name          Type      MEF No.  Cards    Dimensions   Format
        hdulist       HDUList
        phu           PrimaryHDU    0       179
        phu.header    Header
[0]     (\PYGZsq{}SCI\PYGZsq{}, 1)    ImageHDU      1        37    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[1]     (\PYGZsq{}SCI\PYGZsq{}, 2)    ImageHDU      2        37    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[2]     (\PYGZsq{}SCI\PYGZsq{}, 3)    ImageHDU      3        37    (2304, 1056)  float32
           .header    Header
           .data      ndarray
\end{Verbatim}

The structure of the new extension is (from line 8. \code{new\_extension.info()}):

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Filename: N20110316S0321.fits
    Type: AstroData
    Mode: update

AD No.    Name          Type      MEF No.  Cards    Dimensions   Format
        hdulist       HDUList
        phu           PrimaryHDU    0       147
        phu.header    Header
[0]     (\PYGZsq{}SCI\PYGZsq{}, 2)    ImageHDU      1        39    (2304, 1056)  float32
           .header    Header
           .data      ndarray
\end{Verbatim}


\subsection{Appending an extension}
\label{io:appending-an-extension}
Appending and inserting extension can be tricky.  The first difficulty comes
from the naming of the extensions.  No two extensions are allowed to have
the same EXTNAME, EXTVER combination.  When appending or inserting, the
user must either specify the EXTNAME, EXTVER of the new extension or use
the \code{auto\_number} options which tries to do something sensible to keep the
MEF structurally valid.

The second difficulty is due to the fact an assignment of an extension to
a variable is
just a ``reference'', a ``link'', it is not a copy.  Any changes to the
variable standing as a pointer to an extension in an AstroData object will
affect the AstroData object itself.

The \code{append} method adds an extension as the end of a dataset. Here is an
example appending an extension to a dataset.  Further discussion follows.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{new\PYGZus{}extension}\PYG{p}{,} \PYG{n}{auto\PYGZus{}number}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{do\PYGZus{}deepcopy}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

The AstroData method \code{append()} is used to append an extension to
an AstroData object.  On the first line, the extension \code{new\_extension}
gets appended to the \code{ad} dataset.

As you see in the previous subsection, the extension name and extension
version number of the extension in \code{new\_extension} is {[}'SCI', 2{]}.  There
is already an extension named and versioned that way in \code{ad} (see the
result of \code{ad.info()} in the previous subsection).  Therefore, to avoid
conflict, the argument \code{auto\_number} is set to \code{True}.

As you can see from the output of \code{ad.info()} after the \code{append} call:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Filename: N20110313S0188.fits
    Type: AstroData
    Mode: update

AD No.    Name          Type      MEF No.  Cards    Dimensions   Format
        hdulist       HDUList
        phu           PrimaryHDU    0       179
        phu.header    Header
[0]     (\PYGZsq{}SCI\PYGZsq{}, 1)    ImageHDU      1        37    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[1]     (\PYGZsq{}SCI\PYGZsq{}, 2)    ImageHDU      2        37    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[2]     (\PYGZsq{}SCI\PYGZsq{}, 3)    ImageHDU      3        37    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[3]     (\PYGZsq{}SCI\PYGZsq{}, 4)    ImageHDU      4        39    (2304, 1056)  float32
           .header    Header
           .data      ndarray
\end{Verbatim}

There is a new extension at the bottom of the list named {[}'SCI', 4{]} (lines
18-20).  The \code{auto\_number} feature figured out that {[}'SCI', 1 to 3{]} already
existed and assigned the new {[}'SCI'{]} extension a version number of 4 to avoid
conflict.

Now, there is a second issue to deal with.  Since \code{new\_extension} is just
a reference to the extension stored in \code{adread}, when \code{auto\_number}
changes the version number to 4, the extension in \code{adread} will also be
modified, corrupting the source.  Moreover, if other modifications are made
to the extension inserted in \code{ad}, it will modify \code{adread} too. There are
times when it will not matter at all, for example if \code{adread} is scheduled to be closed anyway,
but if \code{adread} is to be used later in the script, it should not be modified
like that.

To cut the link between the extension appended to the dataset and the
source, the argument \code{do\_deepcopy} is set to \code{True}.  This will often be
needed.  It is not the default because of memory usage concerns, and to force
the user to think before creating copies and decide if it is truly needed.


\subsection{Inserting an extension}
\label{io:inserting-an-extension}
When inserting an extension into an AstroData object, the same caution to
extension name and version, and to the reference versus copy issues applies.
Instead of repeating ourselves, we refer to users to the discusssion above in
the ``Appending'' section.

With that in mind, let us present a few examples of insertion.


\subsubsection{Simple insertion}
\label{io:simple-insertion}
To insert an extension between the PHU and the first extension:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{new\PYGZus{}extension} \PYG{o}{=} \PYG{n}{adread}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{new\PYGZus{}extension}\PYG{o}{.}\PYG{n}{rename\PYGZus{}ext}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{new\PYGZus{}extension}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{ad}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{new\PYGZus{}extension}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

On Line 2, we rename the extension to `VAR' simply to make it stand out
once inserted.  Also, note that since the new extension is named {[}'VAR',1{]},
it does not conflict with any of the extensions already present in \code{ad},
therefore there were no need for activating the \code{auto\_number} option. We
did not use \code{do\_deepcopy} either.  As consequence, the source of
\code{new\_extension}, \code{adread}, has been modified (in memory).

Before and after insertion, \code{new\_extension} has this structure:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Filename: N20110316S0321.fits
    Type: AstroData
    Mode: update

AD No.    Name          Type      MEF No.  Cards    Dimensions   Format
        hdulist       HDUList
        phu           PrimaryHDU    0       147
        phu.header    Header
[0]     (\PYGZsq{}VAR\PYGZsq{}, 1)    ImageHDU      1        39    (2304, 1056)  float32
           .header    Header
           .data      ndarray
\end{Verbatim}

The actual insertion takes place on Line 5.  The syntax requires the
first argument to be the position number, or the name and version,
of the extension to ``push''.  The new extension will be inserted \emph{before}
the extension specified in the statement.  The second argument is obviously
the extension to insert into \code{ad}.

After insertion, \code{ad} looks like this:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Filename: N20110313S0188.fits
    Type: AstroData
    Mode: update

AD No.    Name          Type      MEF No.  Cards    Dimensions   Format
        hdulist       HDUList
        phu           PrimaryHDU    0       179
        phu.header    Header
[0]     (\PYGZsq{}VAR\PYGZsq{}, 1)    ImageHDU      1        39    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[1]     (\PYGZsq{}SCI\PYGZsq{}, 1)    ImageHDU      2        37    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[2]     (\PYGZsq{}SCI\PYGZsq{}, 2)    ImageHDU      3        37    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[3]     (\PYGZsq{}SCI\PYGZsq{}, 3)    ImageHDU      4        37    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[4]     (\PYGZsq{}SCI\PYGZsq{}, 4)    ImageHDU      5        39    (2304, 1056)  float32
           .header    Header
           .data      ndarray
\end{Verbatim}

As one can see, \code{new\_extension} is now the first extension in the file
structure, or at position 0 (Lines 9-11), and the other extensions have been
moved ``down''.


\subsubsection{A tricky insertion}
\label{io:a-tricky-insertion}
The name of the new extension {[}'VAR',1{]} was not in conflict with any
pre-existing extensions in the original AstroData object.  Let us insert
the new extension again, in another position in the current AstroData object.
This time, there is a {[}'VAR', 1{]} in the AstroData object, and \code{auto\_number}
and \code{do\_deepcopy} are required.

The \code{auto\_number} option is required to avoid the extension name clash.
Less obvious is why \code{do\_deepcopy} is required, assuming that we do not
care about the impact on \code{adread}.  The reason is subtle, and clearly
illustrate why extension manipulations is probably the most tricky concept
in this manual, yet fortunately not that commonly needed.

When we inserted \code{new\_extension} above, we did not use \code{do\_deepcopy}.
Therefore, if we were to modify \code{new\_extension}, like through \code{auto\_number},
we would be modifying not only the source, \code{adread}, but also that extension
we have already added to \code{ad} !

As you can see, it is vitally important to understand was is a true copy and
what is a reference to something else when dealing with extensions.  Beginners
might want to use \code{do\_deepcopy=True} as a default, until they are comfortable
with the concept of references.  \emph{Beware} however that memory usage can
rise significantly.

Here is how one would insert \code{new\_extension} somewhere else in \code{ad}.
In the example, the extension is inserted between the current third and
fourth extension.  Since position ID are zero-indexed, this means between
position 2 and 3.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{new\PYGZus{}extension}\PYG{p}{,} \PYG{n}{auto\PYGZus{}number}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{do\PYGZus{}deepcopy}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

Look at what happened to the name of the newly inserted extension
(Lines 18-20):

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Filename: N20110313S0188.fits
    Type: AstroData
    Mode: update

AD No.    Name          Type      MEF No.  Cards    Dimensions   Format
        hdulist       HDUList
        phu           PrimaryHDU    0       179
        phu.header    Header
[0]     (\PYGZsq{}VAR\PYGZsq{}, 1)    ImageHDU      1        39    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[1]     (\PYGZsq{}SCI\PYGZsq{}, 1)    ImageHDU      2        37    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[2]     (\PYGZsq{}SCI\PYGZsq{}, 2)    ImageHDU      3        37    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[3]     (\PYGZsq{}VAR\PYGZsq{}, 5)    ImageHDU      4        39    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[4]     (\PYGZsq{}SCI\PYGZsq{}, 3)    ImageHDU      5        37    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[5]     (\PYGZsq{}SCI\PYGZsq{}, 4)    ImageHDU      6        39    (2304, 1056)  float32
           .header    Header
           .data      ndarray
\end{Verbatim}

The automatic renumbering assigned an extension number of 5 to the newly
inserted extension.  One might have expected that 2 would be assigned as the
next available version number of the `VAR' name.  This behavior was designed
to prevent the software from making the scientific assumption that the new
extension is in anyway associated with another.  Normally, it is assumed that
all extension with a given EXTVER are scientifically associated.  \code{auto\_number}
has no way to know which extension is scientifically associated with an other.
The purpose of \code{auto\_number} is solely to keep the AstroData structure sound
and prevent corruption due to clashing name/version pairs.  It is the job
of the programmer, who has the scientific knowledge of the associations, to
name and version the extensions correctly when that matters.


\subsubsection{Using name/version pairs instead of position ID}
\label{io:using-name-version-pairs-instead-of-position-id}
The position at which the insertion is to take place can be given as the
positional ID like in the examples above, or by specify the extension name
and version.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{new\PYGZus{}extension} \PYG{o}{=} \PYG{n}{adread}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{n}{new\PYGZus{}extension}\PYG{o}{.}\PYG{n}{rename\PYGZus{}ext}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{n}{new\PYGZus{}extension}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

In this example, a new extension is retrieved from the source and renamed
`VAR' to avoid name conflict and keep the example simple.  The insertion takes
place on the third line where the position of insertion is specfied as
\code{('SCI',4)}.  The resulting \code{ad} looks like this:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Filename: N20110313S0188.fits
    Type: AstroData
    Mode: update

AD No.    Name          Type      MEF No.  Cards    Dimensions   Format
        hdulist       HDUList
        phu           PrimaryHDU    0       179
        phu.header    Header
[0]     (\PYGZsq{}VAR\PYGZsq{}, 1)    ImageHDU      1        39    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[1]     (\PYGZsq{}SCI\PYGZsq{}, 1)    ImageHDU      2        37    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[2]     (\PYGZsq{}SCI\PYGZsq{}, 2)    ImageHDU      3        37    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[3]     (\PYGZsq{}VAR\PYGZsq{}, 5)    ImageHDU      4        39    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[4]     (\PYGZsq{}SCI\PYGZsq{}, 3)    ImageHDU      5        37    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[5]     (\PYGZsq{}VAR\PYGZsq{}, 3)    ImageHDU      6        39    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[6]     (\PYGZsq{}SCI\PYGZsq{}, 4)    ImageHDU      7        39    (2304, 1056)  float32
           .header    Header
           .data      ndarray
\end{Verbatim}

The new extension pushed (`SCI',4) down and took its place in the sequence.


\subsection{Removing an extension}
\label{io:removing-an-extension}
Compared to appending and inserting extensions, removing them is a breeze.
As before, the extension to remove can be speficied with the position number
or with the extension name and version.  Just remember that the position
numbers are zero-indexed.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{ad}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

After the two removal above, \code{ad} looks like this:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Filename: N20110313S0188.fits
    Type: AstroData
    Mode: update

AD No.    Name          Type      MEF No.  Cards    Dimensions   Format
        hdulist       HDUList
        phu           PrimaryHDU    0       179
        phu.header    Header
[0]     (\PYGZsq{}VAR\PYGZsq{}, 1)    ImageHDU      1        39    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[1]     (\PYGZsq{}SCI\PYGZsq{}, 1)    ImageHDU      2        37    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[2]     (\PYGZsq{}SCI\PYGZsq{}, 2)    ImageHDU      3        37    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[3]     (\PYGZsq{}VAR\PYGZsq{}, 3)    ImageHDU      4        39    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[4]     (\PYGZsq{}SCI\PYGZsq{}, 4)    ImageHDU      5        39    (2304, 1056)  float32
           .header    Header
           .data      ndarray
\end{Verbatim}


\subsection{Updating the existing file on disk}
\label{io:updating-the-existing-file-on-disk}
If a file has been opened in \code{update} mode, the file on disk can be
overwritten with the \code{write()} command.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{filename}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

The first line will print the file name currently associated with the
AstroData object, \code{ad}.  This the file that will be written to.

More often though, the idea is to the write the modified output to a new
file.  This can be done regardless of the \code{mode} used when the file was
opened.  All that is needed is to specify a new file name.  Note that
this will change the file name associated with the AstroData object,
permanently, any other \code{write} commands will write to the new file name.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{filename}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{newfile.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{filename}
\end{Verbatim}

Before the write, the file name is \code{N20110313S0188.fits}.  After the write,
the file name is \code{newfile.fits}.


\subsection{Closing and cleaning up}
\label{io:closing-and-cleaning-up}
It is recommended to properly close the opened AstroData objects when they are
no longer needed:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{adread}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

If you have been following along, the input file on disk was modified by
one of the \code{write} examples above.  We will need the unmodified file in
the next section.  To restore the file to the original:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{shutil}
\PYG{n}{shutil}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{../data\PYGZus{}for\PYGZus{}ad\PYGZus{}user\PYGZus{}manual/N20110313S0188.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}


\section{Create New MEF Files}
\label{io:create-new-mef-files}
A new MEF file can be created from a copy of an existing file or created
from scratch with AstroData objects.


\subsection{Create New Copy of MEF Files}
\label{io:create-new-copy-of-mef-files}
Let us consider the case where you already have a MEF file on disk and you want
to work on it and write the modified MEF to a new file.


\subsubsection{Basic example}
\label{io:basic-example}
Open a file, make modifications, write a new MEF file on disk:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N20110313S0188.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{modifications} \PYG{n}{here} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{newfile2.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\subsubsection{Needing true copies in memory}
\label{io:needing-true-copies-in-memory}
Since in Python, and when working with AstroData objects, the memory can be
shared between variables, it is sometimes necessary to create a ``true'' copy
of an AstroData object to keep us from modifying the original.

By using \code{deepcopy} on an AstroData object the copy is a true copy, it gets
given its own memory allocation.  This allows one to modify the copy while
leaving the original AstroData intact.  This feature is useful when an
operation requires both the modified and the original AstroData object since
by design a simple copy or assignment points to a common location in memory.
Use carefully however, your memory usage can grow rapidly if you over-use.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{k+kn}{from} \PYG{n+nn}{copy} \PYG{k+kn}{import} \PYG{n}{deepcopy}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N20110313S0188.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{adcopy} \PYG{o}{=} \PYG{n}{deepcopy}\PYG{p}{(}\PYG{n}{ad}\PYG{p}{)}
\end{Verbatim}

In the example above, \code{adcopy} is now completely independent copy of \code{ad}.
This also means that you have doubled the memory footprint.  Also note that
both copies have the same file name associated to them; be mindful of that
if you \code{write} the files back to disk.


\subsection{Create New MEF Files from Scratch}
\label{io:create-new-mef-files-from-scratch}
Another use case is creating a new MEF files or AstroData object when none
existed before. The pixel data needs to be created as a Numpy \code{ndarray}.
The header must be created as PyFITS header. IMPORTANT: AstroData currently
is not compatible with \code{astropy.io.fits}, one \emph{must} use the standalone
PyFITS module (it comes with Ureka).

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{k+kn}{import} \PYG{n+nn}{pyfits} \PYG{k+kn}{as} \PYG{n+nn}{pf}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{c}{\PYGZsh{} Create an empty header.}
\PYG{n}{new\PYGZus{}header} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{Header}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Create a pixel data array.}
\PYG{n}{new\PYGZus{}data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1000.}\PYG{p}{,} \PYG{l+m+mi}{2048}\PYG{o}{*}\PYG{l+m+mi}{1024}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{l+m+mi}{2048}\PYG{p}{,}\PYG{l+m+mi}{1024}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Create an AstroData object and give it a filename}
\PYG{n}{new\PYGZus{}ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{n}{data}\PYG{o}{=}\PYG{n}{new\PYGZus{}data}\PYG{p}{,} \PYG{n}{header}\PYG{o}{=}\PYG{n}{new\PYGZus{}header}\PYG{p}{)}
\PYG{n}{new\PYGZus{}ad}\PYG{o}{.}\PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{gradient.fits}\PYG{l+s}{\PYGZsq{}}

\PYG{c}{\PYGZsh{} Write the file to disk and close}
\PYG{n}{new\PYGZus{}ad}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{new\PYGZus{}ad}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

The input header does not need to have anything in it (Line 6).  In fact, if
you are really creating from scratch, it is probably better to leave it empty
and populate it after the creation of the AstroData object.  Upon creation,
AstroData, through PyFITS, will take care of adding the minimal set of header
cards to make the file FITS compliant.

The pixel data array must be a \code{ndarray}.  On Line 9, we create a
1024 x 2048 array, filled with a gradient of pixel value.

It is important to attach a name to the AstroData object (line 13) if it is to
be written to disk.  No default names are assigned to new AstroData objects.


\chapter{AstroDataTypes}
\label{types:astrodatatypes}\label{types::doc}\label{types:types}

\section{What are AstroDataTypes}
\label{types:what-are-astrodatatypes}
AstroDataTypes are AstroData's way to know about itself.  When a file is
opened with AstroData, the headers are inspected, data identification rules
are applied, and all applicable AstroDataTypes are assigned.  From that point
on, the AstroData object ``knows'' whether it is a GMOS image, a NIRI spectrum,
an IFU from GMOS or NIFS. This embedded knowledge is critical to the header
keyword mapping done by the Descriptors (see
{\hyperref[headers:headers]{\emph{Section 4 - FITS Headers}}}), for examples.
The RecipeSystem also depends heavily on the AstroDataType feature.

Examples of AstroDataTypes are: GMOS\_IMAGE, SIDEREAL, GMOS\_IFU\_FLAT, NIRI\_CAL,
NIRI\_SPECT, GEMINI\_SOUTH, etc.

The AstroDataTypes can also refer to data processing status, eg. RAW.  This
feature is not used as much yet.

The types are obviously observatory and instrument dependent.  The
identification rules do need to be coded for AstroData to assign
AstroDataTypes.  This has been done for most if not all Gemini data.  The
Gemini Types are included in the \code{astrodata\_Gemini} package that is
installed along with \code{astrodata} when \code{gemini\_python} is installed.
Keeping the instrument rules and configuration separate from \code{astrodata}
keeps it generic, and allows other packages to be easily added, for example,
one might want to add a third-party package for CFHT instruments.


\section{Using AstroDataTypes}
\label{types:using-astrodatatypes}
\textbf{Try it yourself}

If you wish to follow along and try the commands yourself, download
the data package, go to the \code{playground} directory and copy over
the necessary files.

\begin{Verbatim}[commandchars=\\\{\}]
cd \PYGZlt{}path\PYGZgt{}/gemini\PYGZus{}python\PYGZus{}datapkg\PYGZhy{}X1/playground
cp ../data\PYGZus{}for\PYGZus{}ad\PYGZus{}user\PYGZus{}manual/N20111124S0203.fits .
\end{Verbatim}

Then launch the Python shell:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{python}
\end{Verbatim}

The attribute \code{types} is a common way to check the AstroDataType and make
logic decisions based to on the type.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N20111124S0203.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{k}{if} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GMOS\PYGZus{}IMAGE}\PYG{l+s}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{types}\PYG{p}{:}
   \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{I am a GMOS Image.}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{else}\PYG{p}{:}
   \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{I am these types instead: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{types}
\end{Verbatim}

The attribute \code{types} is a list of all the AstroDataTypes
associated with the dataset.  Other than for controlling the flow of the
program, it can be useful when interactively exploring the various types
associated with a dataset, or when there's a need to write all the types
to the screen or to a file, for logging purposes, for example.

If you have a set of Gemini datasets on disk and you wish to know which
AstroDataTypes are associated with them, use the shell tool \code{typewalk}
in that directory and you will be served a complete list of types for each
datasets in that directory.  Try it in the \code{data\_for\_ad\_user\_manual}
directory.  Open another shell (not the interactive Python shell) and

\begin{Verbatim}[commandchars=\\\{\}]
cd \PYGZlt{}path\PYGZgt{}/gemini\PYGZus{}python\PYGZus{}datapkg\PYGZhy{}X1/data\PYGZus{}for\PYGZus{}ad\PYGZus{}user\PYGZus{}manual
typewalk
\end{Verbatim}

You will get:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
directory: /data/giraf/gemini\PYGZus{}python\PYGZus{}datapkg\PYGZhy{}X1/data\PYGZus{}for\PYGZus{}ad\PYGZus{}user\PYGZus{}manual
     estgsS20080220S0078.fits .......... (GEMINI) (GEMINI\PYGZus{}SOUTH) (GMOS)
     ................................... (GMOS\PYGZus{}LS) (GMOS\PYGZus{}S) (GMOS\PYGZus{}SPECT) (LS)
     ................................... (PREPARED) (SIDEREAL) (SPECT)
     gmosifu\PYGZus{}cube.fits ................. (GEMINI) (GEMINI\PYGZus{}SOUTH) (GMOS)
     ................................... (GMOS\PYGZus{}IFU) (GMOS\PYGZus{}IFU\PYGZus{}BLUE)
     ................................... (GMOS\PYGZus{}IFU\PYGZus{}RED) (GMOS\PYGZus{}IFU\PYGZus{}TWO)
     ................................... (GMOS\PYGZus{}S) (GMOS\PYGZus{}SPECT) (IFU)
     ................................... (PREPARED) (SIDEREAL) (SPECT)
     N20110313S0188.fits ............... (GEMINI) (GEMINI\PYGZus{}NORTH) (GMOS)
     ................................... (GMOS\PYGZus{}IMAGE) (GMOS\PYGZus{}N) (GMOS\PYGZus{}RAW)
     ................................... (IMAGE) (RAW) (SIDEREAL) (UNPREPARED)
     N20110316S0321.fits ............... (CAL) (GEMINI) (GEMINI\PYGZus{}NORTH) (GMOS)
     ................................... (GMOS\PYGZus{}CAL) (GMOS\PYGZus{}IMAGE)
     ................................... (GMOS\PYGZus{}IMAGE\PYGZus{}FLAT)
     ................................... (GMOS\PYGZus{}IMAGE\PYGZus{}TWILIGHT) (GMOS\PYGZus{}N)
     ................................... (GMOS\PYGZus{}RAW) (IMAGE) (RAW) (SIDEREAL)
     ................................... (UNPREPARED)
     N20111124S0203.fits ............... (CAL) (GEMINI) (GEMINI\PYGZus{}NORTH) (GMOS)
     ................................... (GMOS\PYGZus{}CAL) (GMOS\PYGZus{}IFU) (GMOS\PYGZus{}IFU\PYGZus{}FLAT)
     ................................... (GMOS\PYGZus{}IFU\PYGZus{}RED) (GMOS\PYGZus{}N) (GMOS\PYGZus{}RAW)
     ................................... (GMOS\PYGZus{}SPECT) (IFU) (RAW) (SIDEREAL)
     ................................... (SPECT) (UNPREPARED)
\end{Verbatim}

The attribute \code{types} returns all the processing status flags as well as
the types proper.  Those two concepts can be separated.  The method \code{type()}
returns only types, no status; the method \code{status()} returns only processing
status, no types.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{type}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{status}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

The \code{type()} statement returns:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GMOS\PYGZus{}IFU}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GMOS\PYGZus{}IFU\PYGZus{}RED}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{IFU}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GEMINI\PYGZus{}NORTH}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GMOS\PYGZus{}N}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GMOS\PYGZus{}IFU\PYGZus{}FLAT}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GMOS\PYGZus{}CAL}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GEMINI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SIDEREAL}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GMOS\PYGZus{}SPECT}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{CAL}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GMOS}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SPECT}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

and the \code{status()} statement returns:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GMOS\PYGZus{}RAW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{UNPREPARED}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{RAW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

If code applies modifications to the AstroData object that result in changes to
the AstroDataTypes, it is necessary to let the system know about it.  The
method \code{refresh\_types()} rescan the AstroData headers and reapply the
identification rules.  This type refreshing is used mostly when the processing
status needs to be changed, for example once the raw data has been
standardized, it's processing status becomes ``PREPARED''.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{refresh\PYGZus{}types}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\section{Creating New AstroDataTypes {[}Advanced Topic{]}}
\label{types:creating-new-astrodatatypes-advanced-topic}
\begin{notice}{note}{Todo}

Primer on creating new AstroDataTypes.
\end{notice}

\begin{notice}{note}{Note:}
refer to programmer's manual, but give some idea of what needs to be done
and the basic principles
\end{notice}


\chapter{FITS Headers}
\label{headers:headers}\label{headers::doc}\label{headers:fits-headers}
\textbf{Try it yourself}

If you wish to follow along and try the commands yourself, download
the data package, go to the \code{playground} directory and copy over
the necessary file.

\begin{Verbatim}[commandchars=\\\{\}]
cd \PYGZlt{}path\PYGZgt{}/gemini\PYGZus{}python\PYGZus{}datapkg\PYGZhy{}X1/playground
cp ../data\PYGZus{}for\PYGZus{}ad\PYGZus{}user\PYGZus{}manual/N20111124S0203.fits .
\end{Verbatim}

Then launch the Python shell:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{python}
\end{Verbatim}


\section{AstroData Descriptors}
\label{headers:astrodata-descriptors}
AstroData Descriptors provide a ``header keyword-to-concept'' mapping that
allows one to access header information in a consistent manner, regardless
of which instrument the dataset is from.  Like for the AstroDataTypes, the
mapping is coded in a configuration package that is provided by the
observatory or the user.

For example, if one were interested to know the filter used for an
observation, normally one would need to know which specific keyword or set of
keywords to look at for that instrument.  However, once the concept of
``filter'' is coded in a Descriptor, one now only needs to call the
\code{filtername} Descriptor to retrieve the information.

The Descriptors are closely associated with AstroDataTypes.  The AstroDataType
of the AstroData object will tell the Descriptor system which piece of the
configuration package code to call to retrieve the information requested.

\begin{notice}{note}{Note:}
If the Descriptors have not been configured for a dataset's specific
AstroDataType, or if the AstroDataType for the data had not been defined,
in the configuration package, the Descriptors will not work.  In that case,
it is nevertheless possible to access AstroData header information directly
with the pyfits interface.  This is also shown later in this chapter.
\end{notice}

To get the list of descriptors available for an AstroData object:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N20111124S0203.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{descriptors}
\PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{ad}\PYG{o}{.}\PYG{n}{descriptors}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

The \code{descriptors} property returns a dictionary with the name of the
descriptors available for this AstroData object as the keys.  The really
interesting information is in the keys.  On Line 5, we retrieve the
sorted list of available Descriptors.

Most Descriptor names are readily understood, but one can get a short
description of what the Descriptor refers to by calling the Python help
function, for example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{help}\PYG{p}{(}\PYG{n}{ad}\PYG{o}{.}\PYG{n}{airmass}\PYG{p}{)}
\end{Verbatim}

Descriptors associated with standard FITS keywords are defined in the
\code{ADCONFIG\_FITS} package found in \code{astrodata\_FITS}.  All the Descriptors
associated with other concepts used by the Gemini software are found in the
\code{ADCONFIG\_Gemini} package, part of \code{astrodata\_Gemini}.

A user reducing Gemini data or coding for existing Gemini data only need to
make sure that \code{astrodata\_FITS} and \code{astrodata\_Gemini} have been
installed.  A user coding for a new Gemini instrument, or for another
observatory, will need to write the configuration code for the new Descriptors
and AstrodataTypes.  That is an advanced topic not covered by this manual.


\section{Accessing Headers}
\label{headers:accessing-headers}

\subsection{Accessing headers with Descriptors}
\label{headers:accessing-headers-with-descriptors}
Whenever possible the Descriptors should be used to get information from the
headers.  This allows for maximum re-use of the code as it will work on any
datasets with an AstroDataTypes. Here are a few examples using Descriptors:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N20111124S0203.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{}\PYGZhy{}\PYGZhy{}\PYGZhy{} print a value}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{The airmass is : }\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{ad}\PYG{o}{.}\PYG{n}{airmass}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{}\PYGZhy{}\PYGZhy{}\PYGZhy{} use a value to control the flow}
\PYG{k}{if} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{exposure\PYGZus{}time}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{240.}\PYG{p}{:}
   \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{This is a short exposure}\PYG{l+s}{\PYGZsq{}}
\PYG{k}{else}\PYG{p}{:}
   \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{This is a long exposure}\PYG{l+s}{\PYGZsq{}}

\PYG{c}{\PYGZsh{}\PYGZhy{}\PYGZhy{}\PYGZhy{} multiply all extensions by their respective gain}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{The average before: }\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{average}\PYG{p}{(}\PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{The gain for [SCI,2]}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{gain}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{ad}\PYG{o}{.}\PYG{n}{mult}\PYG{p}{(}\PYG{n}{ad}\PYG{o}{.}\PYG{n}{gain}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{The average after: }\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{average}\PYG{p}{(}\PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}

\PYG{c}{\PYGZsh{}\PYGZhy{}\PYGZhy{}\PYGZhy{} do arithmetics}
\PYG{n}{fwhm\PYGZus{}pixel} \PYG{o}{=} \PYG{l+m+mf}{3.5}
\PYG{n}{fwhm\PYGZus{}arcsec} \PYG{o}{=} \PYG{n}{fwhm\PYGZus{}pixel} \PYG{o}{*} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{pixel\PYGZus{}scale}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{The FWHM in arcsec is: }\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fwhm\PYGZus{}arcsec}
\end{Verbatim}

The Descriptors are returned as DescriptorValue objects. In many types of
statements the DescriptorValue will be automatically converted to the
appropriate Python type based on context.  All the Descriptor calls above
do that convertion.  For example, on Line 25, the DescriptorValue returned
by \code{pixel\_scale()} is converted to a Python float for the multiplication.

The AstroData arithmetics used on Line 19 will be discussed in more details
in a later chapter.  Essentially, the \code{gain()} Descriptor returns a
DescriptorValue with gain information for each of the 6 extensions.  Then
AstroData's \code{mult} method multiplies each pixel data extensions with the
appropriate gain value for that extension.  No looping necessary, AstroData
and Descriptors are taking care of it.

When the automatic convertion to a Python cannot be determine from context
the programmer must use the method \code{as\_pytype()}.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{pixel\PYGZus{}scale}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{pixel\PYGZus{}scale}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{as\PYGZus{}pytype}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

The first line returns a DescriptorValue, the second line returns a float.


\subsection{Accessing headers directly}
\label{headers:accessing-headers-directly}
Not all the header content has been mapped with Descriptors, nor should it.
The header content is nevertheless accessible.  With direct access, there
are no DescriptorValue involved and the type returned matches what is stored
in the header.

One important thing to keep in mind is that the PHU and the extension headers
are accessed differently. The method \code{phu\_get\_key\_value} accesses the PHU
header; the method \code{get\_key\_value} accesses the header of the specified
extension.

Here are some direct access examples:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N20111124S0203.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Get keyword value from the PHU}
\PYG{n}{aofold\PYGZus{}position} \PYG{o}{=} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{phu\PYGZus{}get\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{AOFOLD}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Get keyword value from a specific extension}
\PYG{k}{print} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{get\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{NAXIS2}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Get keyword value for all SCI extensions}
\PYG{k}{for} \PYG{n}{extension} \PYG{o+ow}{in} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{:}
   \PYG{n}{naxis2} \PYG{o}{=} \PYG{n}{extension}\PYG{o}{.}\PYG{n}{get\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{NAXIS2}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
   \PYG{k}{print} \PYG{n}{naxis2}
\end{Verbatim}


\subsection{Whole headers}
\label{headers:whole-headers}
Entire headers can be retrieve as PyFITS Header object.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c}{\PYGZsh{} Get the header for the PHU}
\PYG{n}{phuhdr} \PYG{o}{=} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{phu}\PYG{o}{.}\PYG{n}{header}

\PYG{c}{\PYGZsh{} Get the header for extension SCI, 1}
\PYG{n}{exthdr} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{header}
\end{Verbatim}

In the interactive Python shell, listing the header contents to screen can be
done as follow:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c}{\PYGZsh{} For the PHU}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{phu}\PYG{o}{.}\PYG{n}{header}

\PYG{c}{\PYGZsh{} For a specific extension:}
\PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{header}

\PYG{c}{\PYGZsh{} For all the extensions:  (PHU excluded)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{headers}
\end{Verbatim}


\subsection{EXTNAME and EXTVER}
\label{headers:extname-and-extver}
MEF files have the concept of naming and versioning extensions.  The header
keywords storing the name and version are \code{EXTNAME} and \code{EXTVER}.  AstroData uses
that concept extensively.  In fact, even if a MEF on disk does not have
\code{EXTNAME} and \code{EXTVER} defined, for example Gemini raw datasets, upon
opening the file AstroData will assign names and versions to each extension.
The default behavior is to assign all extension a \code{EXTNAME} of \code{SCI}
and then version them sequential from 1 to the number of extension present.

The name and version of an extension is obtained this way:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{name} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{extname}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{version} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{extver}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{name}\PYG{p}{,} \PYG{n}{version}
\end{Verbatim}


\section{Updating and Adding Headers}
\label{headers:updating-and-adding-headers}
Header cards can be updated or added to the headers.  As for the simple access
to the headers, there are methods to work on the PHU and different methods to
work on the extensions.

The methods to update and add headers mirror the access methods.  The method
\code{phu\_set\_key\_value()} modifies the PHU.  The method \code{set\_key\_value()}
modifies the extension headers.

The inputs to the \code{phu\_set\_key\_value} and \code{set\_key\_value} methods are
\emph{keyword}, \emph{value}, \emph{comment}.  The comment is optional.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N20111124S0203.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Add a header card to the PHU}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{phu\PYGZus{}set\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MYTEST}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{99}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Some meaningless keyword}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Modify a header card in the second extension}
\PYG{n}{ad}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GAIN}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mf}{5.}\PYG{p}{)}

\PYG{c}{\PYGZsh{} The extension can also be specified by name and version.}
\PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GAIN}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{10.}\PYG{p}{)}

\PYG{c}{\PYGZsh{} In a loop}
\PYG{k}{for} \PYG{n}{extension} \PYG{o+ow}{in} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{:}
   \PYG{n}{extension}\PYG{o}{.}\PYG{n}{set\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{TEST}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{This is a test.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

The \code{set\_key\_value} method works only on an extension, it will not work
on the whole AstroData object. For example, the following \textbf{will not}
work:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} DOES NOT WORK.  An extension must be specified.}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{set\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{TEST}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{This test does not work}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}


\subsection{EXTNAME and EXTVER}
\label{headers:id1}
The name and version of an extension are so critical to AstroData that, like
for access, the editing of \code{EXTNAME} and \code{EXTVER} is done through a special
method.

The name and version of an extension can be set or reset manually with the
\code{rename\_ext} method:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{rename\PYGZus{}ext}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}
\end{Verbatim}

Be careful with this function.  Having two extensions with the same name and
version in an AstroData data object, or a MEF files for that matter, can lead
to strange problems.


\section{Adding Descriptors for New Instruments {[}Advanced Topic{]}}
\label{headers:adding-descriptors-for-new-instruments-advanced-topic}
\begin{notice}{note}{Todo}

Primer on Descriptor definitions for new instrument.
\end{notice}

\begin{notice}{note}{Note:}
refer to Descriptors document for complete instructions
\end{notice}


\chapter{Pixel Data}
\label{data:data}\label{data::doc}\label{data:pixel-data}
\textbf{Try it yourself}

If you wish to follow along and try the commands yourself, download
the data package, go to the \code{playground} directory and copy over
the necessary files.

\begin{Verbatim}[commandchars=\\\{\}]
cd \PYGZlt{}path\PYGZgt{}/gemini\PYGZus{}python\PYGZus{}datapkg\PYGZhy{}X1/playground
cp ../data\PYGZus{}for\PYGZus{}ad\PYGZus{}user\PYGZus{}manual/N20110313S0188.fits .
cp ../data\PYGZus{}for\PYGZus{}ad\PYGZus{}user\PYGZus{}manual/gmosifu\PYGZus{}cube.fits .
cp ../data\PYGZus{}for\PYGZus{}ad\PYGZus{}user\PYGZus{}manual/estgsS20080220S0078.fits .
\end{Verbatim}

Then launch the Python shell:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{python}
\end{Verbatim}


\section{Operate on the Pixel Data}
\label{data:operate-on-the-pixel-data}
The pixel data are stored in a numpy \code{ndarray}.  Therefore anything
that can be done with numpy on a \code{ndarray} can be done on the pixel
data stored in the AstroData object.  Examples include arithmetic,
statistics, display, plotting, etc.  Please refer to numpy documentation
for details on what it offers.  In this chapter, we will present some typical
examples.

But first, here is how to acess the data array stored in an AstroData
object.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N20110313S0188.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{the\PYGZus{}data} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}

\PYG{c}{\PYGZsh{} Loop through the extensions.}
\PYG{k}{for} \PYG{n}{extension} \PYG{o+ow}{in} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{:}
   \PYG{n}{the\PYGZus{}data} \PYG{o}{=} \PYG{n}{extension}\PYG{o}{.}\PYG{n}{data}
   \PYG{k}{print} \PYG{n}{the\PYGZus{}data}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

An extension's \code{data} attribute returns a numpy \code{ndarray}.  An extension
must be specified by name (Line 5) or position ID, or extracted from the
main AstroData object (Line 8).  Also, remember that PHUs do not have any
pixel data, so none of what is discussed in this chapter applies to the PHU.

The AstroData pixel data can be manipulated like any other \code{ndarray}.  For
example, on Line 10, we calculate the sum of the pixel values with the
\code{ndarray} \code{sum()} method.


\section{Arithmetic on AstroData Objects}
\label{data:arithmetic-on-astrodata-objects}
AstroData supports basic arithmetic directly:

\begin{tabulary}{\linewidth}{|L|L|}
\hline

addition
 & 
.add()
\\

subtraction
 & 
.sub()
\\

multiplication
 & 
.mult()
\\

division
 & 
.div()
\\
\hline\end{tabulary}


The big advantage of using the AstroData
implementation of those operator is that if the AstroData object has variance
and data quality planes, those will be calculated and propagated to the
output appropriately.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N20110313S0188.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} addition}
\PYG{c}{\PYGZsh{}   ad = ad + 5.}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+m+mf}{5.}\PYG{p}{)}

\PYG{c}{\PYGZsh{} subtraction}
\PYG{c}{\PYGZsh{}   ad = ad \PYGZhy{} 5.}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{sub}\PYG{p}{(}\PYG{l+m+mf}{5.}\PYG{p}{)}

\PYG{c}{\PYGZsh{} multiplication.  Using descriptor as operand.}
\PYG{c}{\PYGZsh{}   ad = ad * gain}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{mult}\PYG{p}{(}\PYG{n}{ad}\PYG{o}{.}\PYG{n}{gain}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} division. Using descriptor as operand.}
\PYG{c}{\PYGZsh{}   ad = ad / gain}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{div}\PYG{p}{(}\PYG{n}{ad}\PYG{o}{.}\PYG{n}{gain}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

When using AstroData arithmetic, all the science frames (\code{EXTNAME='SCI'})
are operated on.  The modifications are \textbf{done in-place}, the AstroData
object is modified.

The AstroData arithmetic methods can be stringed together.  Note that because
the calculations are done ``in-place'', \textbf{operator precedence cannot be
respected}. For example,

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mult}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sub}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}

\PYG{c}{\PYGZsh{} means:  ad = ((ad + 5) * 10) \PYGZhy{} 5}
\PYG{c}{\PYGZsh{} not: ad = ad + (5 * 10) \PYGZhy{} 5}
\end{Verbatim}

The AstroData data arithmetic method modify the data ``in-place''.  This means
that the data values are modified and the original values are no more.  If
you need to keep the original values unmodified, for example, you will need
them later, use \code{deepcopy} to make a separate copy on which you can work.

Let us say that we want to calculate \code{y = x*10 + x} where \code{x} is the
pixel values.  We must use \code{deepcopy} here since after \code{ad.mult(10)} the
values in \code{ad} will have been modified and cannot be used for the \code{+ x}
part of the equation.

Let us follow a pixel through the math.

The WRONG way to calculate \code{x*10 + x}:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N20110313S0188.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{value\PYGZus{}before} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{]}
\PYG{n}{expected\PYGZus{}value\PYGZus{}after} \PYG{o}{=} \PYG{n}{value\PYGZus{}before}\PYG{o}{*}\PYG{l+m+mi}{10} \PYG{o}{+} \PYG{n}{value\PYGZus{}before}

\PYG{n}{ad}\PYG{o}{.}\PYG{n}{mult}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{ad}\PYG{p}{)}
\PYG{n}{bad\PYGZus{}value\PYGZus{}after} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{]}

\PYG{k}{print} \PYG{n}{expected\PYGZus{}value\PYGZus{}after}\PYG{p}{,} \PYG{n}{bad\PYGZus{}value\PYGZus{}after}

\PYG{n}{ad}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} The result of the arithmetic above is y = (x*10) + (x*10)}
\end{Verbatim}

The CORRECT way to calculate \code{x*10 + x}:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{k+kn}{from} \PYG{n+nn}{copy} \PYG{k+kn}{import} \PYG{n}{deepcopy}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N20110313S0188.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{adcopy} \PYG{o}{=} \PYG{n}{deepcopy}\PYG{p}{(}\PYG{n}{ad}\PYG{p}{)}

\PYG{n}{value\PYGZus{}before} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{]}
\PYG{n}{expected\PYGZus{}value\PYGZus{}after} \PYG{o}{=} \PYG{n}{value\PYGZus{}before}\PYG{o}{*}\PYG{l+m+mi}{10} \PYG{o}{+} \PYG{n}{value\PYGZus{}before}

\PYG{n}{ad}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{adcopy}\PYG{o}{.}\PYG{n}{mult}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{good\PYGZus{}value\PYGZus{}after} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{expected\PYGZus{}value\PYGZus{}after}\PYG{p}{,} \PYG{n}{good\PYGZus{}value\PYGZus{}after}

\PYG{n}{ad}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{adcopy}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

As one can see, for complex equation, using the AstroData arithmetic method
can get fairly confusing.  Operator overload would solve this situation but
it has not been implemented yet mostly due to a lack of resources.  Therefore,
we recommend the use numpy for really complex equation since operator overload
is implemented in numpy and the operator precedence is respected.  The
downside is that if you need the variance plane propagated correctly, you will
have to do the math yourself.

Here is the \code{y = x*10 + x} operation again, but this time numpy is used on
the \code{ndarray} returned by \code{.data}.  Like before, we follow a pixel through
the math.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N20110313S0188.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{value\PYGZus{}before} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{]}
\PYG{n}{expected\PYGZus{}value\PYGZus{}after} \PYG{o}{=} \PYG{n}{value\PYGZus{}before}\PYG{o}{*}\PYG{l+m+mi}{10} \PYG{o}{+} \PYG{n}{value\PYGZus{}before}

\PYG{k}{for} \PYG{n}{extension} \PYG{o+ow}{in} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{:}
    \PYG{n}{data\PYGZus{}array} \PYG{o}{=} \PYG{n}{extension}\PYG{o}{.}\PYG{n}{data}
    \PYG{n}{data\PYGZus{}array} \PYG{o}{=} \PYG{n}{data\PYGZus{}array}\PYG{o}{*}\PYG{l+m+mi}{10} \PYG{o}{+} \PYG{n}{data\PYGZus{}array}
    \PYG{n}{extension}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{data\PYGZus{}array}

\PYG{n}{value\PYGZus{}after} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{expected\PYGZus{}value\PYGZus{}after}\PYG{p}{,} \PYG{n}{value\PYGZus{}after}

\PYG{n}{ad}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\section{Variance}
\label{data:variance}
The AstroData arithmetic methods can propagate the variance planes, if any are
present.  The variance extensions must be named \code{VAR} to be recognized as
such.

The initial variance from read noise and poisson noise normally needs to be
calculated by the programmer; the raw data normally contains only science
extensions.


\subsection{Adding variance extensions}
\label{data:adding-variance-extensions}
For the sake of simplicity, only the poisson noise is considered in this
example.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N20110313S0188.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{extension} \PYG{o+ow}{in} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{:}
   \PYG{n}{variance} \PYG{o}{=} \PYG{n}{extension}\PYG{o}{.}\PYG{n}{data} \PYG{o}{/} \PYG{n}{extension}\PYG{o}{.}\PYG{n}{gain}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{as\PYGZus{}pytype}\PYG{p}{(}\PYG{p}{)}
   \PYG{n}{variance\PYGZus{}header} \PYG{o}{=} \PYG{n}{extension}\PYG{o}{.}\PYG{n}{header}
   \PYG{n}{variance\PYGZus{}extension} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{n}{data}\PYG{o}{=}\PYG{n}{variance}\PYG{p}{,} \PYG{n}{header}\PYG{o}{=}\PYG{n}{variance\PYGZus{}header}\PYG{p}{)}
   \PYG{n}{variance\PYGZus{}extension}\PYG{o}{.}\PYG{n}{rename\PYGZus{}ext}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
   \PYG{n}{ad}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{variance\PYGZus{}extension}\PYG{p}{)}

\PYG{n}{ad}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Let\PYGZsq{}s save a copy of this dataset.}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N188\PYGZus{}with\PYGZus{}var.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ad}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

On Line 6, the loop through all the science extension is launched.  The
Poisson noise will be calculated for each science extension and stored in a
new extension named `VAR'.  The extension version informs on the association
between the `SCI' and the `VAR' extensions, eg. {[}'VAR', 1{]} is the variance
for {[}'SCI', 1{]}.

For each science extension, the variance is calculated from the pixel data
and the gain obtained from the Descriptor \code{.gain} (Line 7).  Note the use
of \code{as\_pytype()} on the Descriptor.  Since \code{extension.data} is a
\code{ndarray} not a standard Python type, the DescriptorValue does not know
how it is expected to behave, requiring the use of \code{as\_pytype()} which
converts the DescriptorValue to a Python float.

On Line 8, we simply copy the header for the science extension and use that
as the header for the new variance extension (Line 9).

The new variance extension is renamed to `VAR' on Line 10 -- it was `SCI' since
we copied the header -- and append the extension to the AstroData object
(Line 11).

Finally, we write that AstroData object to a new MEF on disk.  We will use
that MEF in the next examples.

For reference, the AstroData object before the variance planes are added looks
like this:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Filename: N20110313S0188.fits
    Type: AstroData
    Mode: readonly

AD No.    Name          Type      MEF No.  Cards    Dimensions   Format
        hdulist       HDUList
        phu           PrimaryHDU    0       179
        phu.header    Header
[0]     (\PYGZsq{}SCI\PYGZsq{}, 1)    ImageHDU      1        37    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[1]     (\PYGZsq{}SCI\PYGZsq{}, 2)    ImageHDU      2        37    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[2]     (\PYGZsq{}SCI\PYGZsq{}, 3)    ImageHDU      3        37    (2304, 1056)  float32
           .header    Header
           .data      ndarray
\end{Verbatim}

After the variance planes are added, the structure looks like this:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Filename: N20110313S0188.fits
    Type: AstroData
    Mode: readonly

AD No.    Name          Type      MEF No.  Cards    Dimensions   Format
        hdulist       HDUList
        phu           PrimaryHDU    0       179
        phu.header    Header
[0]     (\PYGZsq{}SCI\PYGZsq{}, 1)    ImageHDU      1        37    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[1]     (\PYGZsq{}SCI\PYGZsq{}, 2)    ImageHDU      2        37    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[2]     (\PYGZsq{}SCI\PYGZsq{}, 3)    ImageHDU      3        37    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[3]     (\PYGZsq{}VAR\PYGZsq{}, 1)    ImageHDU      4        37    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[4]     (\PYGZsq{}VAR\PYGZsq{}, 2)    ImageHDU      5        37    (2304, 1056)  float32
           .header    Header
           .data      ndarray
[5]     (\PYGZsq{}VAR\PYGZsq{}, 3)    ImageHDU      6        37    (2304, 1056)  float32
           .header    Header
           .data      ndarray
\end{Verbatim}


\subsection{Automatic variance propagation}
\label{data:automatic-variance-propagation}
As mentioned before, if the AstroData arithmetic methods are used, the
variance will be propagated automatically.  A simple \code{ad.mult()} suffices
to multiply the science pixels and calculate the resulting variance, for all
extensions.

Let us follow a science pixel and a variance pixel through the AstroData
arithmetic.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c}{\PYGZsh{}     output = x * x}
\PYG{c}{\PYGZsh{} var\PYGZus{}output = var * x\PYGZca{}2 + var * x\PYGZca{}2}

\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{Astrodata}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N188\PYGZus{}with\PYGZus{}var.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{value\PYGZus{}before} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{]}
\PYG{n}{variance\PYGZus{}before} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{]}
\PYG{n}{expected\PYGZus{}value\PYGZus{}after} \PYG{o}{=} \PYG{n}{value\PYGZus{}before} \PYG{o}{+} \PYG{n}{value\PYGZus{}before}
\PYG{n}{expected\PYGZus{}variance\PYGZus{}after} \PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{p}{(}\PYG{n}{variance\PYGZus{}before} \PYG{o}{*} \PYG{n}{value\PYGZus{}before} \PYG{o}{*} \PYG{n}{value\PYGZus{}before}\PYG{p}{)}

\PYG{n}{ad}\PYG{o}{.}\PYG{n}{mult}\PYG{p}{(}\PYG{n}{ad}\PYG{p}{)}

\PYG{n}{value\PYGZus{}after} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{]}
\PYG{n}{variance\PYGZus{}after} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{expected\PYGZus{}value\PYGZus{}after}\PYG{p}{,} \PYG{n}{value\PYGZus{}after}
\PYG{k}{print} \PYG{n}{expected\PYGZus{}variance\PYGZus{}after}\PYG{p}{,} \PYG{n}{variance\PYGZus{}after}

\PYG{n}{ad}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

So all it took to multiply the science extensions by themselves and propagate
the variance accordingly was \code{ad.mult(ad)} (Line 13).


\subsection{Manual propagation with numpy}
\label{data:manual-propagation-with-numpy}
To do the same thing as \code{ad.mult(ad)}, but by operating directly on the
numpy arrays of each extension:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N188\PYGZus{}with\PYGZus{}var.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} This loop is the equivalent of {}`{}`ad.mult(ad){}`{}`}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{ad}\PYG{o}{.}\PYG{n}{count\PYGZus{}exts}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{d} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}
    \PYG{n}{v} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{d}\PYG{o}{*}\PYG{n}{d}
    \PYG{n}{variance} \PYG{o}{=} \PYG{n}{v} \PYG{o}{*} \PYG{n}{d}\PYG{o}{*}\PYG{n}{d} \PYG{o}{+} \PYG{n}{v} \PYG{o}{*} \PYG{n}{d}\PYG{o}{*}\PYG{n}{d}
    \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{data}
    \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{variance}

\PYG{n}{ad}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\section{Display}
\label{data:display}
Displaying \code{ndarray} arrays from Python is straighforward with the
\code{numdisplay} module.  The module also has a function to read the position
the cursor, which can be useful when developing an interactive tool.

The \code{numdisplay} module is a module of the \code{stsci.tools} package
distributed in Ureka.


\subsection{Displaying}
\label{data:displaying}
To display the pixel data of an AstroData extension, the
\code{numdisplay.display} function is used. A display tool, like DS9 or ximtool,
must also be running.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{k+kn}{from} \PYG{n+nn}{stsci.numdisplay} \PYG{k+kn}{import} \PYG{n}{display}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N20110313S0188.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{display}\PYG{p}{(}\PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}

\PYG{c}{\PYGZsh{} To scale \PYGZdq{}a la IRAF\PYGZdq{}}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,} \PYG{n}{zscale}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}

\PYG{c}{\PYGZsh{} To set the minimum and maximum values to display}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,} \PYG{n}{z1}\PYG{o}{=}\PYG{l+m+mi}{700}\PYG{p}{,} \PYG{n}{z2}\PYG{o}{=}\PYG{l+m+mi}{2000}\PYG{p}{)}
\end{Verbatim}

\code{numdisplay.display} accepts various arguments. See \code{help(display)} to
get more information.  The examples on Line 6, 9, and 12, are probably the
most common, especially for users coming from IRAF.


\subsection{Retrieving cursor position}
\label{data:retrieving-cursor-position}
The function \code{numdisplay.readcursor} can be used to retrieve cursor position.
Note that it will \textbf{not} respond to mouse clicks, \textbf{only} keyboard entries
are acknowledged.

When invoked, \code{readcursor()} will stop the flow of the program and wait for
the user to put the cursor on top of the image and type a key.  A \textbf{string}
with four space-separated values are going to be returned: the x and y
coordinates, a frame reference number, and the value of the key the user hit.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c}{\PYGZsh{} here we assume that the previous example has just been run.}

\PYG{k+kn}{from} \PYG{n+nn}{stsci.numdisplay} \PYG{k+kn}{import} \PYG{n}{readcursor}

\PYG{c}{\PYGZsh{} User instructions: Put cursor on image, type a key.}
\PYG{n}{cursor\PYGZus{}coo} \PYG{o}{=} \PYG{n}{readcursor}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{cursor\PYGZus{}coo}

\PYG{c}{\PYGZsh{} To extract only the x,y coordinates:}
\PYG{p}{(}\PYG{n}{xcoo}\PYG{p}{,} \PYG{n}{ycoo}\PYG{p}{)} \PYG{o}{=} \PYG{n}{cursor\PYGZus{}coo}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{xcoo}\PYG{p}{,} \PYG{n}{ycoo}

\PYG{c}{\PYGZsh{} If you are also interested in the keystoke:}
\PYG{p}{(}\PYG{n}{xcoo}\PYG{p}{,} \PYG{n}{ycoo}\PYG{p}{,} \PYG{n}{junk}\PYG{p}{,} \PYG{n}{keystroke}\PYG{p}{)} \PYG{o}{=} \PYG{n}{cursor\PYGZus{}coo}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{You pressed this key: }\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{keystroke}
\end{Verbatim}


\section{Useful tools from the Numpy and SciPy Modules}
\label{data:useful-tools-from-the-numpy-and-scipy-modules}
Like the Display section, this section is not really specific to AstroData,
but is rather an introduction to numpy and scipy, and to using those modules
on \code{ndarray} objects.  Since AstroData pixel data is stored in that format,
it is believe important to show a few examples to steer new users in the
right direction.

The \code{numpy} and \code{scipy} modules offer a multitude of functions and tools.
They both have their own documentation.  Here we simply highlighting a few
functions that could be used for common things an astronomer might want to do.
The idea is to get the reader started in her exploration of \code{numpy} and
\code{scipy}.


\subsection{ndarray}
\label{data:ndarray}
\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N20110313S0188.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}

\PYG{c}{\PYGZsh{} Shape of array, (NAXIS2, NAXIS1)}
\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}

\PYG{c}{\PYGZsh{} Value of pixel with IRAF coordinates (100, 50)}
\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{49}\PYG{p}{,}\PYG{l+m+mi}{99}\PYG{p}{]}

\PYG{c}{\PYGZsh{} Data type}
\PYG{n}{data}\PYG{o}{.}\PYG{n}{dtype}
\end{Verbatim}

The two most important thing to remember for users coming from the IRAF world
are that the array has the y-axis in the first index, the x-axis in the second
(Line 8, 11), and that the array indices are zero-indexed, not one-indexed
(Line 11).

Sometimes it is useful to know the type of the values stored in the array,
eg. integer, float, double-precision, etc., this information is obtained with
\code{dtype} (Line 14).


\subsection{Simple numpy statistics}
\label{data:simple-numpy-statistics}
A lot of functions and methods are available in numpy to probe the array, too
many to cover here, but here are a couple examples.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{average}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{median}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\end{Verbatim}

Note how \code{mean()} is called differently from the other two.  \code{mean()} is
a \code{ndarray} method, the others are numpy functions.  The implementation
details are clearly well beyond the scope of this manual, but when looking
for the tool you need, keep in mind that there are two sets of functions to
look into.  Duplications like \code{.mean()} and \code{np.average()} can happen,
but they are not the norm.  The readers are strongly encouraged to refer to the
numpy documentation to find the tool they need.


\subsection{Clipped statistics}
\label{data:clipped-statistics}
It is common in astronomy to apply clipping to the statistics, a clipped
average, for example.

The numpy \code{ma} module can be used to create masks of the values to reject.

In the example below, we calculate a clipped mean with rejection at
+/- 3 times the standard deviation.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{numpy.ma} \PYG{k+kn}{as} \PYG{n+nn}{ma}

\PYG{n}{stddev} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{mean} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{clipped\PYGZus{}mean} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{masked\PYGZus{}outside}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{mean}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{stddev}\PYG{p}{,} \PYG{n}{mean}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{stddev}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

On Line 6, \code{ma.masked\_outside} identify all values falling outside the
allowed range, and creates a \code{MaskedArray} which is a combination of the
data array and a True/False mask, with True identifying the values to reject.
The really convenient thing is that the method \code{mean} will take this
information and calculate the average ignoring all values tagged for rejection.

WARNING: The \code{numpy.clip} function is not the equivalent of the mask
solution.  As explain in the \code{numpy.clip} documentation, the function
\emph{replaces} the extreme values with the minimum and maximum, it \emph{does not
reject} the extreme values.


\subsection{Filters with scipy}
\label{data:filters-with-scipy}
Another common operation is the filtering of an image, for example convolving
with a gaussian filter.  The scipy module \code{ndimage.filters} offers several
such functions for image processing.  See the scipy documentation for more
details.

The example below applies a gaussian filter to a pixel array.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{scipy.ndimage.filters} \PYG{k+kn}{as} \PYG{n+nn}{filters}
\PYG{k+kn}{from} \PYG{n+nn}{stsci.numdisplay} \PYG{k+kn}{import} \PYG{n}{display}

\PYG{n}{convolved\PYGZus{}data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{size}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
\PYG{n}{sigma} \PYG{o}{=} \PYG{l+m+mf}{10.}
\PYG{n}{filters}\PYG{o}{.}\PYG{n}{gaussian\PYGZus{}filter}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{sigma}\PYG{p}{,} \PYG{n}{output}\PYG{o}{=}\PYG{n}{convolved\PYGZus{}data}\PYG{p}{)}

\PYG{c}{\PYGZsh{} visually compare the convolve image with the original.}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{zscale}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{convolved\PYGZus{}data}\PYG{p}{,} \PYG{n}{zscale}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{frame}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c}{\PYGZsh{} To put the convolved data back in the AstroData object}
\PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{convolved\PYGZus{}data}
\end{Verbatim}

On Line 4, a numpy array of the same size and shape as the input data is
created and filled with zeros.  This receives the output convolved image
produced by the function \code{gaussian\_filter} (Line 6).

On Line 13, the input data is replaced with the convolved data.  Remember
that one will need to use \code{write} to make that change effective on disk.


\subsection{Many other tools}
\label{data:many-other-tools}
The world of \code{numpy}, \code{scipy}, and the new \code{astropy} is rich and vast.
The reader should refer to those packages' documentation to learn more.


\section{Using the AstroData Data Quality Plane}
\label{data:using-the-astrodata-data-quality-plane}
\begin{notice}{note}{Todo}

Write examples that use the DQ plane.  Eg. transform DQ plane in a numpy
mask and do statistics.
\end{notice}


\section{Manipulate Data Sections}
\label{data:manipulate-data-sections}
Sections of the data array can be accessed and processed.  It is important to
note here that when indexing a numpy array, the left most number refers to the
highest dimension's axis (eg. in IRAF sections are in (x,y) format, in Python
they are in (y,x) format). Also important is to remember that the numpy arrays
are 0-indexed, not 1-indexed like in Fortran or IRAF.  For example, in a 2-D
numpy array, the pixel position (x,y) = (50,75) would be accessed as
data{[}74,49{]}.


\subsection{Basic statistics on section}
\label{data:basic-statistics-on-section}
\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N20110313S0188.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}

\PYG{c}{\PYGZsh{} Get statistics for a 25x25 pixel\PYGZhy{}wide box centered on pixel 50,75.}
\PYG{n}{mean} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{62}\PYG{p}{:}\PYG{l+m+mi}{87}\PYG{p}{,}\PYG{l+m+mi}{37}\PYG{p}{:}\PYG{l+m+mi}{62}\PYG{p}{]}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{median} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{median}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{62}\PYG{p}{:}\PYG{l+m+mi}{87}\PYG{p}{,}\PYG{l+m+mi}{37}\PYG{p}{:}\PYG{l+m+mi}{62}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{stddev} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{62}\PYG{p}{:}\PYG{l+m+mi}{87}\PYG{p}{,}\PYG{l+m+mi}{37}\PYG{p}{:}\PYG{l+m+mi}{62}\PYG{p}{]}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{minimum} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{62}\PYG{p}{:}\PYG{l+m+mi}{87}\PYG{p}{,}\PYG{l+m+mi}{37}\PYG{p}{:}\PYG{l+m+mi}{62}\PYG{p}{]}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{maximum} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{62}\PYG{p}{:}\PYG{l+m+mi}{87}\PYG{p}{,}\PYG{l+m+mi}{37}\PYG{p}{:}\PYG{l+m+mi}{62}\PYG{p}{]}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Mean    Median Stddev  Min    Max}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYGZbs{}
   \PYG{n}{mean}\PYG{p}{,} \PYG{n}{median}\PYG{p}{,} \PYG{n}{stddev}\PYG{p}{,} \PYG{n}{minimum}\PYG{p}{,} \PYG{n}{maximum}
\end{Verbatim}

There is one odd thing that the reader should notice.  On Line 9, \code{median}
is not being called like the others.  This is because there is no \code{median}
method associated with a \code{ndarray}.  But there is a numpy function, so that
is what is used.


\subsection{Example - Overscan subtraction}
\label{data:example-overscan-subtraction}
Several concepts from previous chapters are used in this example.
The Descriptors are used to retrieve overscan section and data section
information from the headers.  Numpy statistics is done on the pixel data
sections.  AstroData arithmetics is used to subtract the overscan level.
Finally, the overscan section is trimmed off and the AstroData is written to
a new file.

To make the example more complete, we use the file created in the Variance
section.  We will propagate the variance and trim the variance planes too.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}

\PYG{n}{ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N188\PYGZus{}with\PYGZus{}var.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Get EXTVER\PYGZhy{}keyed dictionary for the overscan section and the data}
\PYG{c}{\PYGZsh{} section.}
\PYG{n}{oversec\PYGZus{}dict} \PYG{o}{=} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{overscan\PYGZus{}section}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{collapse\PYGZus{}by\PYGZus{}extver}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{datasec\PYGZus{}dict} \PYG{o}{=} \PYG{n}{ad}\PYG{o}{.}\PYG{n}{data\PYGZus{}section}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{collapse\PYGZus{}by\PYGZus{}extver}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Loop through the science extensions.}
\PYG{k}{for} \PYG{n}{ext} \PYG{o+ow}{in} \PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{:}
   \PYG{c}{\PYGZsh{}}
   \PYG{n}{extver} \PYG{o}{=} \PYG{n}{ext}\PYG{o}{.}\PYG{n}{extver}\PYG{p}{(}\PYG{p}{)}
   \PYG{c}{\PYGZsh{}}
   \PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n}{x2}\PYG{p}{,} \PYG{n}{y1}\PYG{p}{,} \PYG{n}{y2}\PYG{p}{)} \PYG{o}{=} \PYG{n}{oversec\PYGZus{}dict}\PYG{p}{[}\PYG{n}{extver}\PYG{p}{]}
   \PYG{p}{(}\PYG{n}{dx1}\PYG{p}{,} \PYG{n}{dx2}\PYG{p}{,} \PYG{n}{dy1}\PYG{p}{,} \PYG{n}{dy2}\PYG{p}{)} \PYG{o}{=} \PYG{n}{datasec\PYGZus{}dict}\PYG{p}{[}\PYG{n}{extver}\PYG{p}{]}
   \PYG{c}{\PYGZsh{}}
   \PYG{c}{\PYGZsh{} Measure the overscan level}
   \PYG{n}{mean\PYGZus{}overscan} \PYG{o}{=} \PYG{n}{ext}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{y1}\PYG{p}{:}\PYG{n}{y2}\PYG{p}{,}\PYG{n}{x1}\PYG{p}{:}\PYG{n}{x2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}
   \PYG{c}{\PYGZsh{}}
   \PYG{c}{\PYGZsh{} Append variance and subtract overscan. Variance is propagated.}
   \PYG{n}{ext}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{ad}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{extver}\PYG{p}{]}\PYG{p}{)}
   \PYG{n}{ext}\PYG{o}{.}\PYG{n}{sub}\PYG{p}{(}\PYG{n}{mean\PYGZus{}overscan}\PYG{p}{)}
   \PYG{c}{\PYGZsh{}}
   \PYG{c}{\PYGZsh{} Trim the data to remove the overscan section and keep only}
   \PYG{c}{\PYGZsh{} the data section.}
   \PYG{n}{ext}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{extver}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{ext}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{extver}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{dy1}\PYG{p}{:}\PYG{n}{dy2}\PYG{p}{,}\PYG{n}{dx1}\PYG{p}{:}\PYG{n}{dx2}\PYG{p}{]}
   \PYG{n}{ext}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{extver}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{ext}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{extver}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{dy1}\PYG{p}{:}\PYG{n}{dy2}\PYG{p}{,}\PYG{n}{dx1}\PYG{p}{:}\PYG{n}{dx2}\PYG{p}{]}

\PYG{n}{ad}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N188\PYGZus{}overscanTrimmed.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

The dataset loaded in Line 3 has three `SCI' extensions and three `VAR'
extensions.

On Lines 7 and 8, the descriptors \code{overscan\_section} and \code{data\_section}
are used to retrieve the region information relating to the location
of the overscan section and data section in each extension.  The return
values for each extension is a list of four zero-indexed indices identifying
the x and y axes lower and upper range for the section.

Since the overscan and data sections are the same for a given extension
version regardless of the extension name (ie. `SCI' and `VAR' have
identical size and structure), the section information is keyed by extension
version only with the help of the \code{collapse\_by\_extver()} method (Line 7
and 8).

The content of oversec\_dict is

\begin{Verbatim}[commandchars=\\\{\}]
1: [0, 32, 0, 2304], 2: [0, 32, 0, 2304], 3: [1024, 1056, 0, 2304]\PYGZcb{}
\end{Verbatim}

The overscan section and the data section could have been obtained in the
loop for each extension.  It is however more efficient to retrieve the
descriptor information once than three times in the loop, when it is
possible to do so.

Moving on to the loop starting on Line 11.  For convenience, the extension
version of the current extension is stored in a variable on Line 13.  It
will be used to access the section dictionaries from Line 7 and 8, and to
associate a variance extension to the current extension.

The boundaries of the overscan section and of the data section for the
current extension are assigned to convenient variables on Lines 15 and 16.
The values are zero-indexed to match the \code{ndarray}.

The overscan is here simply calculated as the average within the overscan
section (Line 19).

To simplying our lifes, we want to be using the automatic variance propagation
offered by the AstroData arithmetic utility.  The extension obtained from the
\code{in} on Line 11 is an AstroData object with only the `SCI' extension.  No
variance propagation will occur if there are no `VAR' extension in that
AstroData object.  Therefore, on Line 22, we append the `VAR' extension of the
same version as the `SCI' extension.  When the subtraction is done on Line 23,
the operation affects both the `SCI' extension and the newly appended `VAR'
extension.

Now that the overscan level has been subtracted, that section needs to be
trimmed off.  Only the data section is kept.  This is done on Lines 27 and 28.
Note that after the `VAR' extension is appended, there are two extensions in
the AstroData object, and in order to work with them, they must now be
specified.  Contrast that with the calls on Lines 13 and 19; then there were
still only one extension, the `SCI' extension, and selection was implicit.

A final but important reminder.  All of the work was done on the extensions
extracted from the original AstroData object, \code{ad}.  Since the extensions
are not true copies but rather references to the original source, all the
modifications to \code{ext} are in reality modifications to \code{ad}.  So, now, all
we have to do is write the modified \code{ad} to disk with another name (Line 31).


\section{Data Cubes}
\label{data:data-cubes}
Reduced Integral Field Unit (IFU) data is commonly stored in a cube, a
three-dimensional array.  The \code{data} component of an AstroData object can
be such a cube, and can be manipulated and explored with numpy, plotted with
matplotlib (the next section shows a few more matplotlib examples.)

In the MEF file, the x and y axes are in the first and second dimension, and
the third dimension is for the wavelength axis. In the \code{ndarray}, that order
is reversed.  The dimensions of the \code{ndarray} are (wavelength, y, x).

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{stsci.numdisplay} \PYG{k+kn}{import} \PYG{n}{display}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib.pyplot} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{n}{adcube} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{gmosifu\PYGZus{}cube.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{adcube}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} The shape of the cube, (wavelength, y, x).}
\PYG{n}{adcube}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}

\PYG{c}{\PYGZsh{} Sum along the wavelength axis to create a \PYGZdq{}white light\PYGZdq{} image.}
\PYG{n}{sum\PYGZus{}image} \PYG{o}{=} \PYG{n}{adcube}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sum\PYGZus{}image}\PYG{p}{,} \PYG{n}{zscale}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Plot a 1\PYGZhy{}D spectrum from pixel position (7,30)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{adcube}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{29}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Plot the same thing but with wavelength along the x axis of the plot.}
\PYG{n}{crval3} \PYG{o}{=} \PYG{n}{adcube}\PYG{o}{.}\PYG{n}{get\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{CRVAL3}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{cdelt3} \PYG{o}{=} \PYG{n}{adcube}\PYG{o}{.}\PYG{n}{get\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{CDELT3}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{spec\PYGZus{}pixel\PYGZus{}length} \PYG{o}{=} \PYG{n}{adcube}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{29}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{o}{.}\PYG{n}{size}
\PYG{n}{wavelength} \PYG{o}{=} \PYG{n}{crval3} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{spec\PYGZus{}pixel\PYGZus{}length}\PYG{p}{)}\PYG{o}{*}\PYG{n}{cdelt3}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{clf}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{wavelength}\PYG{p}{,} \PYG{n}{adcube}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{29}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

On Line 13, the cube is ``collapsed'' in the wavelength dimension to produce a
``white light'' 2-D image.

On Line 17, a vector through the cube at pixel position (7,30) is retrieved
and plotted with matplotlib.  The pixel values are plotted against the
zero-indexed pixel position along the wavelength axis.  The \code{show()}
statement (Line 18) might or might not be needed depending on your
\code{interactive} setting in the \code{matplotlibrc} file.

To plot the spectrum with physical units on the plot's x-axis one needs the
WCS information from the header (Lines 21 to 24).  The statement \code{plt.clf()}
simply clears the figure.

People familiar with astropy might prefer to use the \code{wcs} module to
convert pixels to wavelenths (Lines 21 to 24).


\section{Plot Data}
\label{data:plot-data}
In Python, the main tool to create plots is \code{matplotlib}.  We have used it
in the previous section on data cubes.  Here we do not aimed at covering all
of \code{matplotlib}; the reader should refer to that package's documentation.
Rather we will give a few examples that might be of use for quick inspection
of the data.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib.pyplot} \PYG{k+kn}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib.colors} \PYG{k+kn}{import} \PYG{n}{LogNorm}

\PYG{n}{adimg} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N20110313S0188.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{adspec} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{estgsS20080220S0078.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Line plot from image.  Row \PYGZsh{}1044.}
\PYG{n}{line\PYGZus{}index} \PYG{o}{=} \PYG{l+m+mi}{1043}
\PYG{n}{line} \PYG{o}{=} \PYG{n}{adimg}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{line\PYGZus{}index}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{clf}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Column plot from image, averaging across 11 pixels around column \PYGZsh{}327.}
\PYG{n}{col\PYGZus{}index} \PYG{o}{=} \PYG{l+m+mi}{326}
\PYG{n}{width} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{col\PYGZus{}section} \PYG{o}{=} \PYG{n}{adimg}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{col\PYGZus{}index}\PYG{o}{\PYGZhy{}}\PYG{n}{width}\PYG{p}{:}\PYG{n}{col\PYGZus{}index}\PYG{o}{+}\PYG{n}{width}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{column} \PYG{o}{=} \PYG{n}{col\PYGZus{}section}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{clf}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{column}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Contour plot for section}
\PYG{n}{galaxy} \PYG{o}{=} \PYG{n}{adimg}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{1045}\PYG{p}{:}\PYG{l+m+mi}{1085}\PYG{p}{,}\PYG{l+m+mi}{695}\PYG{p}{:}\PYG{l+m+mi}{735}\PYG{p}{]}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{clf}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{galaxy}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{binary}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{norm}\PYG{o}{=}\PYG{n}{LogNorm}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{contour}\PYG{p}{(}\PYG{n}{galaxy}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{equal}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Spectrum in pixel}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{clf}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{adspec}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Spectrum in wavelength (CRPIX1 = 1)}
\PYG{n}{crpix1} \PYG{o}{=} \PYG{n}{adspec}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{get\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{CRPIX1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{crval1} \PYG{o}{=} \PYG{n}{adspec}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{get\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{CRVAL1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{cdelt1} \PYG{o}{=} \PYG{n}{adspec}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{get\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{CDELT1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{length} \PYG{o}{=} \PYG{n}{adspec}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{get\PYGZus{}key\PYGZus{}value}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{NAXIS1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{wavelengths} \PYG{o}{=} \PYG{n}{crval1} \PYG{o}{+} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{length}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{crpix1}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{cdelt1}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{clf}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{wavelengths}\PYG{p}{,} \PYG{n}{adspec}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SCI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\chapter{Table Data}
\label{tables:table-data}\label{tables::doc}
AstroData does not provide any special wrappers for FITS Table Data.  But
since AstroData is built on top of PyFITS, the standard PyFITS
table functions can be used.  The reader should refer to the PyFITS
table documentation for complete details (e.g.
\href{https://pythonhosted.org/pyfits/users\_guide/users\_table.html}{https://pythonhosted.org/pyfits/users\_guide/users\_table.html}). In this chapter,
a few useful examples of basic usage are shown.  As the reader will see, table
manipulation can be tedious and tricky.

\code{astropy.table} might simplify some of the examples presented
in this chapter.  This will be looked into at some future time.  (Suggestions
for improvements are welcome.)

\textbf{Try it yourself}

If you wish to follow along and try the commands yourself, download
the data package, go to the \code{playground} directory and copy over
the necessary files.

\begin{Verbatim}[commandchars=\\\{\}]
cd \PYGZlt{}path\PYGZgt{}/gemini\PYGZus{}python\PYGZus{}datapkg\PYGZhy{}X1/playground
cp ../data\PYGZus{}for\PYGZus{}ad\PYGZus{}user\PYGZus{}manual/estgsS20080220S0078.fits .
\end{Verbatim}

Then launch the Python shell:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{python}
\end{Verbatim}


\section{Read from a FITS Table}
\label{tables:read-from-a-fits-table}
A FITS table is stored in a MEF file as a \code{BinTableHDU}.  The table data is
retrieved from the \code{AstroData} object with the same \code{.data} attribute as
for pixel extensions, but for FITS tables \code{.data} returns a \code{FITS\_rec},
which is a PyFITS class, instead of a Numpy \code{ndarray}.  Here is how to
get information out of a FITS table.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}

\PYG{n}{adspec} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{estgsS20080220S0078.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{adspec}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} For easier reference, assign FITS table to variable.}
\PYG{n}{tabledata} \PYG{o}{=} \PYG{n}{adspec}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MDF}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}

\PYG{c}{\PYGZsh{} Get the column names with \PYGZsq{}names\PYGZsq{} or more details with \PYGZsq{}columns\PYGZsq{}}
\PYG{n}{tabledata}\PYG{o}{.}\PYG{n}{names}
\PYG{n}{tabledata}\PYG{o}{.}\PYG{n}{columns}

\PYG{c}{\PYGZsh{} Get all the data for a column}
\PYG{n}{x\PYGZus{}ccd\PYGZus{}values} \PYG{o}{=} \PYG{n}{tabledata}\PYG{o}{.}\PYG{n}{field}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{x\PYGZus{}ccd}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{third\PYGZus{}col} \PYG{o}{=} \PYG{n}{tabledata}\PYG{o}{.}\PYG{n}{field}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Print the table content}
\PYG{k}{print} \PYG{n}{tabledata}

\PYG{c}{\PYGZsh{} Print the first 2 rows}
\PYG{k}{print} \PYG{n}{tabledata}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}

\PYG{c}{\PYGZsh{} Select rows based on some criterion}
\PYG{n}{select\PYGZus{}tabledata} \PYG{o}{=} \PYG{n}{tabledata}\PYG{p}{[}\PYG{n}{tabledata}\PYG{o}{.}\PYG{n}{field}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{y\PYGZus{}ccd}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{2000.}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{select\PYGZus{}tabledata}
\end{Verbatim}

The first extension in that file is a FITS table with \code{EXTNAME} MDF, and
\code{EXTVER} 1 (Lines 4, 7) .  MDF stands for ``Mask Definition File''.  In
Gemini data, those are used in the data reduction to identify, to first
order, where spectra fall on the detector.

The output of \code{names} (Line 10) is a simple list of strings.  The output
of \code{columns} is a PyFITS \code{ColDefs} object.  When printed it looks like this:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
ColDefs(
    name = \PYGZsq{}ID\PYGZsq{}; format = \PYGZsq{}1J\PYGZsq{}; null = \PYGZhy{}2147483647; disp = \PYGZsq{}A3\PYGZsq{}
    name = \PYGZsq{}x\PYGZus{}ccd\PYGZsq{}; format = \PYGZsq{}1E\PYGZsq{}; disp = \PYGZsq{}F8.2\PYGZsq{}
    name = \PYGZsq{}y\PYGZus{}ccd\PYGZsq{}; format = \PYGZsq{}1E\PYGZsq{}; disp = \PYGZsq{}F8.2\PYGZsq{}
    name = \PYGZsq{}slittype\PYGZsq{}; format = \PYGZsq{}20A\PYGZsq{}; disp = \PYGZsq{}A10\PYGZsq{}
    name = \PYGZsq{}slitid\PYGZsq{}; format = \PYGZsq{}1J\PYGZsq{}; null = \PYGZhy{}2147483647; disp = \PYGZsq{}A3\PYGZsq{}
    name = \PYGZsq{}slitpos\PYGZus{}mx\PYGZsq{}; format = \PYGZsq{}1E\PYGZsq{}; disp = \PYGZsq{}F8.2\PYGZsq{}
    name = \PYGZsq{}slitpos\PYGZus{}my\PYGZsq{}; format = \PYGZsq{}1E\PYGZsq{}; disp = \PYGZsq{}F8.2\PYGZsq{}
    name = \PYGZsq{}slitsize\PYGZus{}mx\PYGZsq{}; format = \PYGZsq{}1E\PYGZsq{}; disp = \PYGZsq{}F8.2\PYGZsq{}
    name = \PYGZsq{}slitsize\PYGZus{}my\PYGZsq{}; format = \PYGZsq{}1E\PYGZsq{}; disp = \PYGZsq{}F8.2\PYGZsq{}
    name = \PYGZsq{}slittilt\PYGZus{}m\PYGZsq{}; format = \PYGZsq{}1E\PYGZsq{}; disp = \PYGZsq{}F8.2\PYGZsq{}
    name = \PYGZsq{}slitsize\PYGZus{}mr\PYGZsq{}; format = \PYGZsq{}1E\PYGZsq{}; disp = \PYGZsq{}F6.2\PYGZsq{}
    name = \PYGZsq{}slitsize\PYGZus{}mw\PYGZsq{}; format = \PYGZsq{}1E\PYGZsq{}; disp = \PYGZsq{}F6.2\PYGZsq{}
)
\end{Verbatim}

When a column is retrieved, like in Lines 14 and 15, the returned value is
a numpy \code{ndarray}.

Note on Line 15 that the third column is in index position 2; all Python
arrays are zero-indexed.


\section{Create a FITS Table}
\label{tables:create-a-fits-table}
Creating a FITS table is mostly a matter of creating the columns, name and
data.  The name is a string, the data is stored in a numpy \code{ndarray}.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{k+kn}{import} \PYG{n+nn}{pyfits} \PYG{k+kn}{as} \PYG{n+nn}{pf}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{c}{\PYGZsh{} Create the input data}
\PYG{n}{snr\PYGZus{}id} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{S001}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{S002}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{S003}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{feii} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{780.}\PYG{p}{,}\PYG{l+m+mf}{78.}\PYG{p}{,}\PYG{l+m+mf}{179.}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{pabeta} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{740.}\PYG{p}{,}\PYG{l+m+mf}{307.}\PYG{p}{,}\PYG{l+m+mf}{220.}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ratio} \PYG{o}{=} \PYG{n}{pabeta}\PYG{o}{/}\PYG{n}{feii}

\PYG{c}{\PYGZsh{} Create the columns}
\PYG{n}{col1} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{Column}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SNR\PYGZus{}ID}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{format}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{4A}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{array}\PYG{o}{=}\PYG{n}{snr\PYGZus{}id}\PYG{p}{)}
\PYG{n}{col2} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{Column}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ratio}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{format}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{E}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{array}\PYG{o}{=}\PYG{n}{ratio}\PYG{p}{)}
\PYG{n}{col3} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{Column}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{feii}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{format}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{E}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{array}\PYG{o}{=}\PYG{n}{feii}\PYG{p}{)}
\PYG{n}{col4} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{Column}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{pabeta}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{format}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{E}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{array}\PYG{o}{=}\PYG{n}{pabeta}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Assemble the columns}
\PYG{n}{cols} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{ColDefs}\PYG{p}{(}\PYG{p}{[}\PYG{n}{col1}\PYG{p}{,} \PYG{n}{col2}\PYG{p}{,} \PYG{n}{col3}\PYG{p}{,} \PYG{n}{col4}\PYG{p}{]}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Create the table HDU}
\PYG{n}{tablehdu} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{new\PYGZus{}table}\PYG{p}{(}\PYG{n}{cols}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Create an AstroData object to contain the table}
\PYG{c}{\PYGZsh{} and write to disk.}
\PYG{n}{new\PYGZus{}ad} \PYG{o}{=} \PYG{n}{AstroData}\PYG{p}{(}\PYG{n}{tablehdu}\PYG{p}{)}
\PYG{n}{new\PYGZus{}ad}\PYG{o}{.}\PYG{n}{rename\PYGZus{}ext}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MYTABLE}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{new\PYGZus{}ad}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{new\PYGZus{}ad}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mytable.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

A new FITS table can also be appended to an already existing AstroData object with
the \code{.append()} function.


\section{Operate on a FITS Table}
\label{tables:operate-on-a-fits-table}
The PyFITS manual is the recommended source for more complete documentation
on working on FITS table with Python.  Here are a few examples of how one can
modify a FITS table.


\subsection{Preparation for the examples}
\label{tables:preparation-for-the-examples}
In order to run the examples in the next few sections, the reader will need
to create these three tables.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{astrodata} \PYG{k+kn}{import} \PYG{n}{AstroData}
\PYG{k+kn}{import} \PYG{n+nn}{pyfits} \PYG{k+kn}{as} \PYG{n+nn}{pf}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{c}{\PYGZsh{} Let us first create tables to play with}
\PYG{n}{snr\PYGZus{}id} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{S001}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{S002}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{S003}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{feii} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{780.}\PYG{p}{,}\PYG{l+m+mf}{78.}\PYG{p}{,}\PYG{l+m+mf}{179.}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{pabeta} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{740.}\PYG{p}{,}\PYG{l+m+mf}{307.}\PYG{p}{,}\PYG{l+m+mf}{220.}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ratio} \PYG{o}{=} \PYG{n}{pabeta}\PYG{o}{/}\PYG{n}{feii}
\PYG{n}{col1} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{Column}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SNR\PYGZus{}ID}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{format}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{4A}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{array}\PYG{o}{=}\PYG{n}{snr\PYGZus{}id}\PYG{p}{)}
\PYG{n}{col2} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{Column}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ratio}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{format}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{E}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{array}\PYG{o}{=}\PYG{n}{ratio}\PYG{p}{)}
\PYG{n}{col3} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{Column}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{feii}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{format}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{E}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{array}\PYG{o}{=}\PYG{n}{feii}\PYG{p}{)}
\PYG{n}{col4} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{Column}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{pabeta}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{format}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{E}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{array}\PYG{o}{=}\PYG{n}{pabeta}\PYG{p}{)}
\PYG{n}{cols\PYGZus{}t1} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{ColDefs}\PYG{p}{(}\PYG{p}{[}\PYG{n}{col1}\PYG{p}{,}\PYG{n}{col3}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{cols\PYGZus{}t2} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{ColDefs}\PYG{p}{(}\PYG{p}{[}\PYG{n}{col1}\PYG{p}{,}\PYG{n}{col4}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{cols\PYGZus{}t3} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{ColDefs}\PYG{p}{(}\PYG{p}{[}\PYG{n}{col2}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{table1} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{new\PYGZus{}table}\PYG{p}{(}\PYG{n}{cols\PYGZus{}t1}\PYG{p}{)}
\PYG{n}{table2} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{new\PYGZus{}table}\PYG{p}{(}\PYG{n}{cols\PYGZus{}t2}\PYG{p}{)}
\PYG{n}{table3} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{new\PYGZus{}table}\PYG{p}{(}\PYG{n}{cols\PYGZus{}t3}\PYG{p}{)}
\end{Verbatim}


\subsection{Merging tables}
\label{tables:merging-tables}
WARNING:  The input tables must \textbf{not} share any common field (ie. column)
names.  For example, \emph{table1} and \emph{table2} created above cannot be merged this
way since they share \code{col1}.

The merging of tables is effectively the equivalent of appending columns.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{merged\PYGZus{}cols} \PYG{o}{=} \PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns} \PYG{o}{+} \PYG{n}{table3}\PYG{o}{.}\PYG{n}{columns}
\PYG{n}{merged\PYGZus{}table} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{new\PYGZus{}table}\PYG{p}{(}\PYG{n}{merged\PYGZus{}cols}\PYG{p}{)}

\PYG{n}{merged\PYGZus{}table}\PYG{o}{.}\PYG{n}{columns}\PYG{o}{.}\PYG{n}{names}  \PYG{c}{\PYGZsh{} or merged\PYGZus{}table.data.names}
\PYG{k}{print} \PYG{n}{merged\PYGZus{}table}\PYG{o}{.}\PYG{n}{data}
\end{Verbatim}

The columns are now:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SNR\PYGZus{}ID}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{feii}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ratio}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

It is interesting to note that table operations are actually \emph{column}
operations followed by the creation of a new table (Lines 1 and 2).
The next example will illustrate this a bit better.


\subsection{Appending and deleting columns}
\label{tables:appending-and-deleting-columns}
\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c}{\PYGZsh{} Append the \PYGZsq{}pabeta\PYGZsq{} column from table2 to table1}
\PYG{n}{index\PYGZus{}of\PYGZus{}pabeta\PYGZus{}col} \PYG{o}{=} \PYG{n}{table2}\PYG{o}{.}\PYG{n}{columns}\PYG{o}{.}\PYG{n}{names}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{pabeta}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns}\PYG{o}{.}\PYG{n}{add\PYGZus{}col}\PYG{p}{(}\PYG{n}{table2}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{[}\PYG{n}{index\PYGZus{}of\PYGZus{}pabeta\PYGZus{}col}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{table1} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{new\PYGZus{}table}\PYG{p}{(}\PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{)}

\PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns}\PYG{o}{.}\PYG{n}{names}
\PYG{k}{print} \PYG{n}{table1}\PYG{o}{.}\PYG{n}{data}
\end{Verbatim}

The append example (Lines 2-4) shows that the real work is done on the
columns, not on the table as such.  To add a column to \code{table1}, once the
columns have been reorganized, a \emph{new} table is created and, in this case,
replaces the original \code{table1}.

The index of the \code{pabeta} column in \code{table2} is found with the \code{index}
method as shown on Line 2.  Then it is just a matter of adding that column
from \code{table2} to the columns of \code{table1} (Line 3).

The columns in the new \code{table1} are:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SNR\PYGZus{}ID}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{feii}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{pabeta}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c}{\PYGZsh{}   To \PYGZdq{}delete\PYGZdq{} the \PYGZsq{}pabeta\PYGZsq{} column from this new table1}
\PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns}\PYG{o}{.}\PYG{n}{del\PYGZus{}col}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{pabeta}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{table1} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{new\PYGZus{}table}\PYG{p}{(}\PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{)}

\PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns}\PYG{o}{.}\PYG{n}{names}
\PYG{k}{print} \PYG{n}{table1}\PYG{o}{.}\PYG{n}{data}
\end{Verbatim}

To delete a column, the process is similar:  the work is done on the columns,
then a \emph{new} table is created to replace the original (Lines 2, 3).

The columns in the final \code{table1} are:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SNR\PYGZus{}ID}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{feii}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}


\subsection{Inserting columns}
\label{tables:inserting-columns}
Column insertion is really about gathering all the columns and reorganizing
them manually.  There are no ``insertion'' tool, per se, in pyfits.
(\code{astropy.table} does have one though.)

Below, we insert the column from \code{table3} in-between the first and second
column of \code{table1}.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{t1\PYGZus{}col1} \PYG{o}{=} \PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{t1\PYGZus{}col2} \PYG{o}{=} \PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{t3\PYGZus{}col1} \PYG{o}{=} \PYG{n}{table3}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{table1} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{new\PYGZus{}table}\PYG{p}{(}\PYG{p}{[}\PYG{n}{t1\PYGZus{}col1}\PYG{p}{,}\PYG{n}{t3\PYGZus{}col1}\PYG{p}{,}\PYG{n}{t1\PYGZus{}col2}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns}\PYG{o}{.}\PYG{n}{names}
\PYG{k}{print} \PYG{n}{table1}\PYG{o}{.}\PYG{n}{data}
\end{Verbatim}

The columns in the resulting \code{table1} are:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SNR\PYGZus{}ID}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ratio}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{feii}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}


\subsection{Changing the name of a column}
\label{tables:changing-the-name-of-a-column}
WARNING: There is a pyfits \code{columns} method called \code{change\_name} but it
does not seem to be working properly.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{[}\PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns}\PYG{o}{.}\PYG{n}{names}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{feii}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}\PYG{o}{.}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ironII}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{table1} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{new\PYGZus{}table}\PYG{p}{(}\PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{)}

\PYG{n}{table1}\PYG{o}{.}\PYG{n}{columns}\PYG{o}{.}\PYG{n}{names}
\end{Verbatim}

To change the name of a column, one needs to change the \code{name} attribute
of the column.  On the first line, the position index of the
column named \code{feii} is used to select the column to change, and then the
name of that column is changed to \code{ironII}.

Again, a \emph{new} table needs to be created once the modifications to the columns
are completed.

The \code{table1} columns are now:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SNR\PYGZus{}ID}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ratio}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ironII}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}


\subsection{Appending and deleting rows}
\label{tables:appending-and-deleting-rows}
Appending and deleting rows is uncannily complicated with PyFITS.
This is an area where the use \code{astropy.table} can certainly help.  We hope
to be able to add astropy-based examples to this manual in the near future.
But for now, let us study the PyFITS way.

\emph{Disclaimer}:  This is the way the author figured out how to do the row
manipulations.  If the reader knows of a better way to do it with PyFITS,
please let us know.

Below, we append two new entries to \code{table2}.  Only the \code{SNR\_ID} and
\code{pabeta} fields will be added to the table since those are the only
two columns in \code{table2}.  When an entry has fields not represented
in the table, those fields are simply ignored.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c}{\PYGZsh{} New entries for object S004 and S005.}
\PYG{n}{new\PYGZus{}entries} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SNR\PYGZus{}ID}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{S004}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{S005}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
             \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ratio}\PYG{l+s}{\PYGZsq{}} \PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{1.12}\PYG{p}{,} \PYG{l+m+mf}{0.72}\PYG{p}{]}\PYG{p}{,}
             \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{feii}\PYG{l+s}{\PYGZsq{}}  \PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{77.}\PYG{p}{,} \PYG{l+m+mf}{87.}\PYG{p}{]}\PYG{p}{,}
             \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{pabeta}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{69.}\PYG{p}{,} \PYG{l+m+mf}{122.}\PYG{p}{]}
             \PYG{p}{\PYGZcb{}}
\PYG{n}{nb\PYGZus{}new\PYGZus{}entries} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{new\PYGZus{}entries}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SNR\PYGZus{}ID}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Create new, larger table.}
\PYG{n}{nrowst2} \PYG{o}{=} \PYG{n}{table2}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{large\PYGZus{}table} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{new\PYGZus{}table}\PYG{p}{(}\PYG{n}{table2}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{,} \PYG{n}{nrows}\PYG{o}{=}\PYG{n}{nrowst2}\PYG{o}{+}\PYG{n}{nb\PYGZus{}new\PYGZus{}entries}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Append the new entries and replace table2 with new table.}
\PYG{k}{for} \PYG{n}{name} \PYG{o+ow}{in} \PYG{n}{table2}\PYG{o}{.}\PYG{n}{columns}\PYG{o}{.}\PYG{n}{names}\PYG{p}{:}
   \PYG{n}{large\PYGZus{}table}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{field}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}\PYG{p}{[}\PYG{n}{nrowst2}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{new\PYGZus{}entries}\PYG{p}{[}\PYG{n}{name}\PYG{p}{]}

\PYG{n}{table2} \PYG{o}{=} \PYG{n}{large\PYGZus{}table}
\PYG{k}{print} \PYG{n}{table2}\PYG{o}{.}\PYG{n}{data}
\end{Verbatim}

The values must be entered for each column separately.  On Lines 14-15,
we loop through the columns by name.  To simplify things, it is convenient
to have the new values stored in a dictionary keyed on the column names
(Lines 2-6).

Adding, and deleting rows (next example), requires the creation of a new table of the correct,
new size (Lines 10-11).

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c}{\PYGZsh{} Delete the last 2 entries from table2}

\PYG{c}{\PYGZsh{} Create new, smaller table.}
\PYG{n}{nb\PYGZus{}bad\PYGZus{}entries} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{nrowst2} \PYG{o}{=} \PYG{n}{table2}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{small\PYGZus{}table} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{new\PYGZus{}table}\PYG{p}{(}\PYG{n}{table2}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{,} \PYG{n}{nrows}\PYG{o}{=}\PYG{n}{nrowst2}\PYG{o}{\PYGZhy{}}\PYG{n}{nb\PYGZus{}bad\PYGZus{}entries}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Copy the large table minus the last two lines to the small table.}
\PYG{k}{for} \PYG{n}{name} \PYG{o+ow}{in} \PYG{n}{table2}\PYG{o}{.}\PYG{n}{columns}\PYG{o}{.}\PYG{n}{names}\PYG{p}{:}
   \PYG{n}{small\PYGZus{}table}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{field}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{table2}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{field}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{n}{nb\PYGZus{}bad\PYGZus{}entries}\PYG{p}{]}

\PYG{n}{table2} \PYG{o}{=} \PYG{n}{small\PYGZus{}table}
\end{Verbatim}


\subsection{Changing a value}
\label{tables:changing-a-value}
Changing a value is simply a matter of identifying the column and the row that
needs the new value.

Below we show how one might search one column to identify the row and then
change that row in another column.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Change the \PYGZsq{}pabeta\PYGZsq{} value for source S002 in table2}
\PYG{n}{rowindex} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{table2}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{field}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SNR\PYGZus{}ID}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{==} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{S002}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{table2}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{field}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{pabeta}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{n}{rowindex}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{888.}
\end{Verbatim}
% Set up the appendix mode and modify the LaTeX toc behavior
\appendix
\noappendicestocpagenum
\addappheadtotoc

\chapter{List of Descriptors}
\label{appendices/appendix_descriptors:list-of-descriptors}\label{appendices/appendix_descriptors:descriptors}\label{appendices/appendix_descriptors::doc}

\section{astrodata\_FITS}
\label{appendices/appendix_descriptors:astrodata-fits}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
\textbf{Descriptor}
} & \textsf{\relax 
\textbf{Short Definition}
} & \textsf{\relax 
\textbf{Python type}
}\\
\hline
instrument
 & 
name of the instrument
 & 
str
\\

object
 & 
name of the target
 & 
str
\\

telescope
 & 
name of the telescope
 & 
str
\\

ut\_date
 & 
UT date
 & 
datetime
\\
\hline\end{tabulary}



\section{astrodata\_Gemini}
\label{appendices/appendix_descriptors:astrodata-gemini}
\begin{longtable}{|l|p{3.0in}|l|}
\hline
\textsf{\relax 
\textbf{Descriptor}
} & \textsf{\relax 
\textbf{Short Definition}
} & \textsf{\relax 
\textbf{Python type}
}\\
\hline\endfirsthead

\multicolumn{3}{c}%
{{\textsf{\tablename\ \thetable{} -- continued from previous page}}} \\
\hline
\textsf{\relax 
\textbf{Descriptor}
} & \textsf{\relax 
\textbf{Short Definition}
} & \textsf{\relax 
\textbf{Python type}
}\\
\hline\endhead

\hline \multicolumn{3}{|r|}{{\textsf{Continued on next page}}} \\ \hline
\endfoot

\endlastfoot


airmass
 & 
airmass of the observation
 & 
float
\\

amp\_read\_area
 & 
combination of amplifier name and 1-indexed section relative
to the detector.
 & 
str
\\

array\_name
 & 
name assigned to the array generated by a given amplifier,
one array per amplifier.
 & 
str
\\

array\_section
 & 
section covered by the array(s), in 0-indexed pixels, relative
to the detector frame (e.g. position of multiple amps read
within a CCD). List of (x1, x2, y1, y2, ...) tuples
 & 
list
\\

azimuth
 & 
pointing position in azimuth
 & 
float
\\

camera
 & 
name of the camera
 & 
str
\\

cass\_rotator\_pa
 & 
position angle of the Cassegrain rotator
 & 
float
\\

central\_wavelength
 & 
central wavelength
 & 
float
\\

coadds
 & 
number of co-adds
 & 
int
\\

data\_label
 & 
Gemini data label
 & 
str
\\

data\_section
 & 
section where the sky-exposed data falls, in 0-indexed pixels.
List of (x1, x2, y1, y2, ...) tuples
 & 
list
\\

dec
 & 
Declination
 & 
float
\\

decker
 & 
name of the decker
 & 
str
\\

detector\_name
 & 
name assigned to the detector
 & 
str
\\

detector\_roi\_setting
 & 
human readable Region Of Interest setting
 & 
str
\\

detector\_rois\_requested
 & 
section defining the Regions Of Interest, in 0-indexed pixels.
List of (x1, x2, y1, y2, ...) tuples
 & 
list
\\

detector\_section
 & 
section covered by the detector(s), in 0-indexed pixels,
relative to the whole mosaic of detectors.
List of (x1, x2, y1, y2, ...) tuples
 & 
list
\\

detector\_x\_bin
 & 
X-axis binning
 & 
int
\\

detector\_y\_bin
 & 
Y-axis binning
 & 
int
\\

disperser
 & 
name of the disperser
 & 
str
\\

dispersion
 & 
value for the dispersion
 & 
float
\\

dispersion\_axis
 & 
dispersion axis
 & 
int
\\

elevation
 & 
pointing position in elevation
 & 
float
\\

exposure\_time
 & 
exposure time
 & 
float
\\

filter\_name
 & 
name of the effective filter
 & 
str
\\

focal\_plane\_mask
 & 
name of the mask in the focal plane
 & 
str
\\

gain
 & 
gain in electrons per ADU
 & 
float
\\

gain\_setting
 & 
human readable gain setting (eg. low, high)
 & 
str
\\

grating
 & 
name of the grating
 & 
str
\\

group\_id
 & 
Gemini observation group ID
 & 
str
\\

local\_time
 & 
local time
 & 
datetime
\\

lyot\_stop
 & 
name of the lyot stop
 & 
str
\\

mdf\_row\_id
 & 
MDF row ID of a cut MOS spectrum
 & 
int
\\

nod\_count
 & 
number of nods
 & 
int
\\

nod\_pixels
 & 
nod offset in pixels
 & 
int
\\

nominal\_atmospheric\_extinction
 & 
nomimal atmospheric extinction
 & 
float
\\

nominal\_photometric\_zeropoint
 & 
nominal photometric zeropoint
 & 
float
\\

non\_linear\_level
 & 
lower boundary of the non-linear regime
 & 
int
\\

observation\_class
 & 
class of observation (eg. calibration, science)
 & 
str
\\

observation\_epoch
 & 
epoch
 & 
str
\\

observation\_id
 & 
Gemini observation ID
 & 
str
\\

observation\_type
 & 
Gemini observation type
 & 
str
\\

overscan\_section
 & 
section where the overscan data falls, in 0-indexed pixels.
List of (x1, x2, y1, y2, ...) tuples
 & 
list
\\

pixel\_scale
 & 
pixel scale in arcsec per pixel
 & 
float
\\

prism
 & 
name of the prism
 & 
str
\\

program\_id
 & 
Gemini program ID
 & 
str
\\

pupil\_mask
 & 
name of the pupil mask
 & 
str
\\

qa\_state
 & 
quality assessment state    (eg. pass, usable, fail)
 & 
str
\\

ra
 & 
right ascension, in degrees
 & 
float
\\

raw\_bg
 & 
Gemini sky background band
 & 
int
\\

raw\_cc
 & 
Gemini cloud coverage band
 & 
int
\\

raw\_iq
 & 
Gemini image quality band
 & 
int
\\

raw\_wv
 & 
Gemini water vapor band
 & 
int
\\

read\_mode
 & 
Gemini name for combination for gain setting and read setting
 & 
str
\\

read\_noise
 & 
read noise in electrons
 & 
float
\\

read\_speed\_setting
 & 
human readable read mode setting (eg. slow, fast)
 & 
str
\\

requested\_bg
 & 
PI requested Gemini sky background band
 & 
int
\\

requested\_cc
 & 
PI requested Gemini cloud coverage band
 & 
int
\\

requested\_iq
 & 
PI requested Gemini image quality band
 & 
int
\\

requested\_wv
 & 
PI requested Gemini water vapor band
 & 
int
\\

saturation\_level
 & 
saturation level
 & 
int
\\

slit
 & 
name of the slit
 & 
str
\\

ut\_datetime
 & 
UT date and time of the observation
 & 
datetime
\\

ut\_time
 & 
UT time of the observation
 & 
datetime
\\

wavefront\_sensor
 & 
wavefront sensor used for the observation
 & 
str
\\

wavelength\_band
 & 
band associated with the filter or the central wavelength
 & 
str
\\

wavelength\_reference\_pixel
 & 
pixel associated with the central wavelength
 & 
float
\\

well\_depth\_setting
 & 
human readable well depth setting (eg. shallow, deep)
 & 
str
\\

x\_offset
 & 
X-axis offset relative to initial pointing position
 & 
float
\\

y\_offset
 & 
Y-axis offset relative to initial pointing position
 & 
float
\\
\hline\end{longtable}


\begin{notice}{note}{Todo}

Write examples that use the DQ plane.  Eg. transform DQ plane in a numpy
mask and do statistics.
\end{notice}

(The {\hyperref[data:index-0]{\emph{original entry}}} is located in  /data/eclipse/workspace/gemini\_python/astrodata/doc/ad\_UsersManual/data.rst, line 579.)

\begin{notice}{note}{Todo}

Primer on Descriptor definitions for new instrument.
\end{notice}

(The {\hyperref[headers:index-0]{\emph{original entry}}} is located in  /data/eclipse/workspace/gemini\_python/astrodata/doc/ad\_UsersManual/headers.rst, line 279.)

\begin{notice}{note}{Todo}

Primer on creating new AstroDataTypes.
\end{notice}

(The {\hyperref[types:index-0]{\emph{original entry}}} is located in  /data/eclipse/workspace/gemini\_python/astrodata/doc/ad\_UsersManual/types.rst, line 152.)



\renewcommand{\indexname}{Index}
\printindex
\end{document}
