.. tags.rst

.. _ad_tags:

****
Tags
****

We described :ref:`above <tags_prop_entry>` how to generate tags for an
AstroData derivative. In this section we'll describe the algorithm that
generates the complete tag set out of the individual ``TagSet`` instances. The
algorithm collects all the tags in a list and then decides whether to apply
them or not following certain rules, but let's talk about ``TagSet`` first.

``TagSet`` is actually a standard named tuple customized to generate default
values (``None``) for its missing members. Its signature is::

    TagSet(add=None, remove=None, blocked_by=None, blocks=None, if_present=None)

The most common ``TagSet`` is an **additive** one: ``TagSet(['FOO', 'BAR'])``.
If all you need is to add tags, then you're done here. But the real power of
our tag generating system is that you can specify some conditions to apply a
certain ``TagSet``, or put restrictions on others. The different arguments to
``TagSet`` all expect a list (or some other work the in the following way):

* ``add``: if this ``TagSet`` is selected, then add all its members to the tag
  set.
* ``remove``: if this ``TagSet`` is selected, then subtract all its members
  from the tag set.
* ``blocked_by``: if any of the tags listed in here exist in the tag set, then
  discard this ``TagSet`` altogether.
* ``blocks``: discard from the list of unprocessed ones any ``TagSet`` that
  would add any of the tags listed here.
* ``if_present``: process this tag only if all the tags listed in here exist in
  the tag set at this point.

Note that ``blocked_by`` and ``blocks`` look like two sides of the same coin.
This is intentional: which one to use is up to the programmer, depending on
what will reduce the amount typing and/or make the logic easier (sometimes one
wants to block a bunch of other tags from a single one; sometimes one wants a
tag to be blocked by a bunch of others).

Now, the algorithm works like this:

1. Collect all the ``TagSet`` generated by methods in the instance that are
   decorated using ``astro_data_tag``.
2. Then we sort them out:

  #. Those that subtract tags from the tag set go first (the ones with
       non-empty ``remove`` or ``blocks``), allowing them to act early on
  #. Those with non-empty ``blocked_by`` are moved to the end of the list, to
       ensure that other tags can be generated before them.
  #. Those with non-empty ``if_present`` are moved behind those with
       ``blocked_by``.

3. Now that we've sorted the tags, process them sequentially and for each one:

  #. If they require other tags to be present, make sure that this is the case.
       If the requirements are not met, drop the tagset; then
  #. Figure out if any other tag is blocking the tagset; then
  #. If all the previous hurdles have been passed, apply the changes declared
       by this tag (add, remove, and/or block others).

Note that Python's sort algorithm is stable. This means, that if two elements are indistinguishable from the point of view of the sorting algorithm, they are guaranteed to stay in the same relative position. To better understand how this affects our tags, and the algorithm itself, let's follow up with an example::

  #TODO : Write an example for the tags
