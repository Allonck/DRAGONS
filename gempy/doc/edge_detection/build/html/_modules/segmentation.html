

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>segmentation &mdash; Trace slits v0.1 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Trace slits v0.1 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">Trace slits v0.1 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for segmentation</h1><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">operator</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="kn">as</span> <span class="nn">nd</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">pl</span>

<span class="kn">from</span> <span class="nn">astrodata</span> <span class="kn">import</span> <span class="n">AstroData</span>
<span class="kn">import</span> <span class="nn">gfit</span>

<span class="n">allowed_functions</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;polynomial&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="Edge"><a class="viewcode-back" href="../documentation.html#segmentation.Edge">[docs]</a><span class="k">class</span> <span class="nc">Edge</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x_array</span><span class="o">=</span><span class="p">[],</span><span class="n">y_array</span><span class="o">=</span><span class="p">[]):</span>
        <span class="c"># Set default values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">=</span> <span class="s">&#39;polynomial&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">x_array</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="o">=</span><span class="p">(</span><span class="n">x_array</span><span class="p">,</span><span class="n">y_array</span><span class="p">)</span>
        
     
<div class="viewcode-block" id="Edge.setfunction"><a class="viewcode-back" href="../documentation.html#segmentation.Edge.setfunction">[docs]</a>    <span class="k">def</span> <span class="nf">setfunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">function</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set a fitting function name.</span>
<span class="sd">            Use this before call to self.fitfunction</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">function</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed_functions</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">,</span>\
                 <span class="s">&#39;setfunction: &#39;</span><span class="o">+</span><span class="n">function</span><span class="o">+</span><span class="s">&#39; is not:&#39;</span><span class="o">+</span><span class="n">allowed_functions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitfunction</span> <span class="o">=</span> <span class="n">function</span>
   </div>
<div class="viewcode-block" id="Edge.setorder"><a class="viewcode-back" href="../documentation.html#segmentation.Edge.setorder">[docs]</a>    <span class="k">def</span> <span class="nf">setorder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">order</span><span class="p">):</span> 
        <span class="sd">&quot;&quot;&quot; Set a fitting function name.</span>
<span class="sd">            Use this before call to self.fitfunction</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">,</span>\
                 <span class="s">&#39;setorder: &#39;</span><span class="o">+</span><span class="n">order</span><span class="o">+</span><span class="s">&#39; is not positive.&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>
</div>
    <span class="k">def</span> <span class="nf">setdimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dimension</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dimension</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">,</span>\
                 <span class="s">&#39;setdimension: &#39;</span><span class="o">+</span><span class="n">dimension</span><span class="o">+</span><span class="s">&#39; is not (1,2,3)&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">dimension</span>

<div class="viewcode-block" id="Edge.fitfunction"><a class="viewcode-back" href="../documentation.html#segmentation.Edge.fitfunction">[docs]</a>    <span class="k">def</span> <span class="nf">fitfunction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Call the actual fit function defined with </span>
<span class="sd">            self.setfunction or use the default function if not.</span>

<span class="sd">            Input: </span>
<span class="sd">              Attribute Edge object having the trace attribute set.</span>

<span class="sd">            Output attributes:</span>
<span class="sd">               coefficients: Fitting coefficients.</span>
<span class="sd">               xlim:    (xmin,xmax)</span>
<span class="sd">               ylim:    (ymin,ymax)</span>
<span class="sd">               evalfunction: function to evaluate.</span>
<span class="sd">                                  </span>
<span class="sd">        &quot;&quot;&quot;</span>
               
        <span class="n">xx</span><span class="p">,</span><span class="n">yy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">fit</span> <span class="o">=</span> <span class="n">gfit</span><span class="o">.</span><span class="n">Gfit</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="n">yy</span><span class="p">,</span><span class="n">fitname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fit</span> <span class="o">=</span> <span class="n">gfit</span><span class="o">.</span><span class="n">Gfit</span><span class="p">(</span><span class="n">yy</span><span class="p">,</span><span class="n">xx</span><span class="p">,</span><span class="n">fitname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>
        <span class="c"># update xlim, ylim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="n">yy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">yy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xlim</span><span class="o">=</span><span class="p">(</span><span class="n">xx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">xx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">coeff</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">evalfunction</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">__call__</span>
 </div></div>
<span class="k">def</span> <span class="nf">_plot_edges_dev</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          NOTE: This for development. For for the</span>
<span class="sd">                public release</span>
<span class="sd">          plot the edges in the list array self.trace</span>
<span class="sd">          i: sequential number, can be edge number</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ed</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
            <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">ed</span><span class="o">.</span><span class="n">trace</span>
            <span class="n">pl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,[</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span> 
            
<span class="k">class</span> <span class="nc">TraceConstraints</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get data-dependent information needed for edge tracing and store in</span>
<span class="sd">    standard variables that will allow the edge tracing to be instrument agnostic.</span>

<span class="sd">    The class is initialize from an Astrodata object.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        orientation:  General orientation of the slit edges.</span>
<span class="sd">                      In degrees.  0 is horizontal, 90 is vertical.</span>
<span class="sd">        filter:       Filter to applied for edge enhancement.  [Default: Sobel]</span>
<span class="sd">                      Allowed/implemented filters:  Sobel.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">allowed_filters</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Sobel&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ad</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="s">&#39;Sobel&#39;</span><span class="p">):</span>


        <span class="c"># Check filter name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setfilter</span><span class="p">(</span><span class="nb">filter</span><span class="p">)</span>

        <span class="n">dispaxis</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">dispersion_axis</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">dispaxis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="mi">90</span>

    <span class="k">def</span> <span class="nf">setorientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orientation</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="n">orientation</span>

    <span class="k">def</span> <span class="nf">setfilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="nb">filter</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">filter</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">TraceConstraints</span><span class="o">.</span><span class="n">allowed_filters</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">SystemError</span><span class="p">,</span> <span class="s">&#39;Requested edge enhancing filter invalid.&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="nb">filter</span>


<span class="k">def</span> <span class="nf">_prefilter</span><span class="p">(</span><span class="n">ad</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      The image have different noise patterns dependent</span>
<span class="sd">      on the instrument. Here we applied a smoothing filter</span>
<span class="sd">      or clipping (depending on the instrument)</span>
<span class="sd">      such that the enhancement filter function produces</span>
<span class="sd">      edges well above the background.</span>

<span class="sd">      Note: We returned the x_ccd, y_ccd from the MDF extension</span>
<span class="sd">            because f2 MDF is not complete.</span>

<span class="sd">      Input:</span>
<span class="sd">           ad: AD object</span>

<span class="sd">      Output:</span>
<span class="sd">           data:     Prefiltered image data</span>
<span class="sd">           xccd:     MDF x-coord slit position</span>
<span class="sd">           yccd:     MDF y-coord slit position</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">instrument</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">instrument</span><span class="p">())</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">ad</span><span class="p">[</span><span class="s">&#39;SCI&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">instrument</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;gnirs&#39;</span><span class="p">]:</span>
        <span class="c"># Clip to normalize the orders; otherwise the</span>
        <span class="c"># high orders would be masked by thresholding done</span>
        <span class="c"># in enhance_edges(). </span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">dmean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data</span><span class="o">&gt;</span><span class="n">dmean</span><span class="p">,</span><span class="n">dmean</span><span class="p">,</span><span class="n">data</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">instrument</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;f2&#39;</span><span class="p">,</span><span class="s">&#39;flam&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span>
        <span class="c"># Smooth input image</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">median_filter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">elif</span> <span class="s">&#39;gmos&#39;</span> <span class="ow">in</span> <span class="n">instrument</span><span class="p">:</span>
        <span class="c"># no prefilter is necessary</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span> \
            <span class="s">&#39;TraceConstraints: Instrument not supported:&#39;</span><span class="o">+</span><span class="n">instrument</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span>
 
    
<div class="viewcode-block" id="trace_edges"><a class="viewcode-back" href="../documentation.html#segmentation.trace_edges">[docs]</a><span class="k">def</span> <span class="nf">trace_edges</span><span class="p">(</span><span class="n">filtered_image</span><span class="p">,</span><span class="n">tc</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      The input image contains well pronounced peaks for each slit edge.</span>
<span class="sd">      The Sobel filtering produces a positive peak when entering the slit</span>
<span class="sd">      and negative peak when exiting.</span>

<span class="sd">      To find these peak we need to threshold the image where each value</span>
<span class="sd">      of the image that is below thresold*sigma (but &gt;0) is set to zero</span>
<span class="sd">      and a value that is greater than the negative threshold*image is</span>
<span class="sd">      set to zero. </span>

<span class="sd">      Now we look for edges by using the ndimage.label function.</span>

<span class="sd">      Input:</span>

<span class="sd">      :param filtered_image: filtered image</span>
<span class="sd">      :param tc: TraceConstraints object containing, among others:</span>
<span class="sd">                    orientation</span>
<span class="sd">      :param threshold: integer. Number of sigmas. (sigma is the standard</span>
<span class="sd">                            deviation calculated over the whole image)</span>

<span class="sd">      Output:</span>

<span class="sd">      :param edges: A list of Edge objects</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">data</span> <span class="o">=</span> <span class="n">filtered_image</span>           <span class="c"># alias for readability</span>
    <span class="n">orientation</span> <span class="o">=</span> <span class="n">tc</span><span class="o">.</span><span class="n">orientation</span>

    <span class="c"># Applied threshold</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>      <span class="c"># Standard deviation from the whole image</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">threshold</span>

    <span class="k">if</span> <span class="n">orientation</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>    <span class="c"># horizontal axis (x-axis)   (gmos)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">orientation</span><span class="o">==</span><span class="mi">90</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>   
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">,</span>\
             <span class="s">&#39;Orientation for filtered_image should be 0 or 90.&#39;</span>
        
    <span class="c"># Select positive features above the threshold*sigma level else</span>
    <span class="c"># set to zero</span>
    <span class="n">bss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data</span><span class="o">&gt;</span><span class="n">n</span><span class="o">*</span><span class="n">sigma</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="c"># Get (x,y) arrays of the positive edges</span>
    <span class="n">xylist</span> <span class="o">=</span> <span class="n">_connect_features</span><span class="p">(</span><span class="n">bss</span><span class="p">,</span><span class="n">axis</span><span class="p">)</span>

    <span class="c"># Select negative features below the threshold*sigma level else</span>
    <span class="c"># set to zero</span>
    <span class="n">bss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data</span><span class="o">&lt;-</span><span class="n">n</span><span class="o">*</span><span class="n">sigma</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="c"># Get (x,y) arrays of the negative  edges</span>
    <span class="n">neg_xylist</span> <span class="o">=</span> <span class="n">_connect_features</span><span class="p">(</span><span class="n">bss</span><span class="p">,</span><span class="n">axis</span><span class="p">)</span>

    <span class="c"># append to positive list</span>
    <span class="n">xylist</span> <span class="o">+=</span> <span class="n">neg_xylist</span>

    <span class="c"># sort in the x or y direction. </span>
    <span class="n">xylist</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span>      <span class="c"># sort in place </span>
    
    <span class="c"># put it on a list of edge object</span>
    <span class="n">edges</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">xylist</span><span class="p">:</span> 
        <span class="n">ed</span> <span class="o">=</span> <span class="n">Edge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>       <span class="c"># Create Edge object </span>
        <span class="n">ed</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="n">orientation</span>
        <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ed</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">edges</span>
</div>
<div class="viewcode-block" id="_connect_features"><a class="viewcode-back" href="../documentation.html#segmentation._connect_features">[docs]</a><span class="k">def</span> <span class="nf">_connect_features</span><span class="p">(</span><span class="n">bss</span><span class="p">,</span><span class="n">axis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">      Find all the connected components and produce an array of</span>
<span class="sd">      edge coordinates. A component in this context is an area of</span>
<span class="sd">      pixels that are connect by proximity defined by an structuring</span>
<span class="sd">      element ::</span>

<span class="sd">               (default: [[0,1,0],</span>
<span class="sd">                         [1,1,1],</span>
<span class="sd">                         [0,1,0]] </span>
<span class="sd">      **Example:**</span>
<span class="sd">     </span>
<span class="sd">      :: </span>

<span class="sd">        a = array([[ 0,  0, 20, 33,  0,  0],</span>
<span class="sd">                   [ 0,  0,  0, 25,  0,  0],</span>
<span class="sd">                   [19, 22,  0,  0, 33,  0],</span>
<span class="sd">                   [ 0,  0,  0, 24,  0,  0]])</span>

<span class="sd">        &gt;&gt;&gt; labeled_array, num_features = nd.label(a)</span>
<span class="sd">        &gt;&gt;&gt; print labeled_array</span>
<span class="sd">            (array([[0, 0, 1, 1, 0, 0],</span>
<span class="sd">                    [0, 0, 0, 1, 0, 0],</span>
<span class="sd">                    [2, 2, 0, 0, 3, 0],</span>
<span class="sd">                    [0, 0, 0, 4, 0, 0]]),</span>

<span class="sd">      Input:</span>
<span class="sd">           :param bss: Thresholded image</span>
<span class="sd">           :param axis: 0: if vertical slits</span>
<span class="sd">                 1: if horizontal slits</span>

<span class="sd">      Output:</span>
<span class="sd">          :param xylist: List of tuples (x_array,y_array) of edge coordinates.</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c"># Get an array of integer labels (1..nl)</span>
    <span class="n">ll</span><span class="p">,</span><span class="n">nl</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">bss</span><span class="p">)</span>

    <span class="c"># Get the rectangles that enclosed each component.</span>
    <span class="n">oo</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">find_objects</span><span class="p">(</span><span class="n">ll</span><span class="p">,</span><span class="n">nl</span><span class="p">)</span>

    <span class="c"># initialize the list of edge object.</span>
    <span class="n">xylist</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c"># Loop thru all the labels (1...nl)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">nl</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>                 
        <span class="n">xc</span><span class="o">=</span><span class="p">[];</span> <span class="n">yc</span><span class="o">=</span><span class="p">[]</span>          <span class="c"># initialize this edge coordinates list of tuples</span>
        <span class="n">sp</span><span class="o">=</span><span class="n">oo</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">axis</span><span class="p">]</span>    

        <span class="c"># For speed do not process small chunks.</span>
        <span class="k">if</span> <span class="n">sp</span><span class="o">.</span><span class="n">stop</span><span class="o">-</span><span class="n">sp</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span> <span class="k">continue</span>     

        <span class="c"># get all the indices for label j</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ll</span><span class="o">==</span><span class="n">j</span><span class="p">)</span>
        <span class="n">yy</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">xx</span><span class="o">=</span><span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c"># Get the row indices, and unique indices</span>
        <span class="n">un</span><span class="p">,</span><span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span><span class="n">return_inverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="c"># Now go along the spatial axis and look for the maximum </span>
        <span class="c"># value in the gradient direction (since an edge can be up to</span>
        <span class="c"># 5 pixel wide). Mark this position.</span>
        <span class="n">nun</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">un</span><span class="p">)</span>
        <span class="c"># Scan along an edge skipping at 5% intervals.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nun</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">nun</span><span class="o">/</span><span class="mi">20</span><span class="p">)):</span>
            <span class="n">yi</span> <span class="o">=</span> <span class="n">yy</span><span class="p">[</span><span class="n">ind</span><span class="o">==</span><span class="n">i</span><span class="p">]</span>        <span class="c"># the indices of unique rows</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="n">xx</span><span class="p">[</span><span class="n">ind</span><span class="o">==</span><span class="n">i</span><span class="p">]</span>        <span class="c"># the indices of columns in the row</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="k">break</span>
            <span class="c"># From Sobel: see if it is positive or negative</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> 
                <span class="n">xi</span><span class="p">,</span><span class="n">yi</span><span class="o">=</span><span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,(</span><span class="n">xi</span><span class="p">,</span><span class="n">yi</span><span class="p">))</span>
                <span class="n">xc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xi</span><span class="p">);</span> <span class="n">yc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">yi</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bss</span><span class="p">[</span><span class="n">yi</span><span class="p">,</span><span class="n">xi</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span> <span class="n">peak</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">bss</span><span class="p">[</span><span class="n">yi</span><span class="p">,</span><span class="n">xi</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>                        <span class="n">peak</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">bss</span><span class="p">[</span><span class="n">yi</span><span class="p">,</span><span class="n">xi</span><span class="p">])</span>
                <span class="n">xc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">peak</span><span class="p">]);</span> <span class="n">yc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">yi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">xylist</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">xylist</span>

</div>
<div class="viewcode-block" id="enhance_edges"><a class="viewcode-back" href="../documentation.html#segmentation.enhance_edges">[docs]</a><span class="k">def</span> <span class="nf">enhance_edges</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="s">&#39;Sobel&#39;</span><span class="p">,</span><span class="n">orientation</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Applied filter to input data. The default filter</span>
<span class="sd">      requires an input orientation. Using the default Sobel</span>
<span class="sd">      filter, 0 degrees is the horizontal axis along which to</span>
<span class="sd">      calculate the enhancement. An orientation value of</span>
<span class="sd">      90 will process egde enhancements in the vertical direction.</span>
<span class="sd">    </span>
<span class="sd">      Input:</span>

<span class="sd">      :param data: 2D input image array.</span>
<span class="sd">      :param filter: input filter name to applied to input array.</span>
<span class="sd">      :type filter: &#39;Sobel&#39; is the default filter name. We use the</span>
<span class="sd">                     scipy.ndimage.filter.sobel implementation. </span>
<span class="sd">      :param orientation: Angle to be used by the filter function.</span>
<span class="sd">      :type orientation: Degrees. Default value is 0.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> 

    <span class="k">if</span> <span class="nb">filter</span> <span class="o">==</span> <span class="s">&#39;Sobel&#39;</span><span class="p">:</span> 
        <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">orientation</span> <span class="o">==</span> <span class="mi">90</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">,</span><span class="s">&#39;Orientation for Sobel filter is 0 or 90.&#39;</span>

        <span class="k">return</span> <span class="n">nd</span><span class="o">.</span><span class="n">sobel</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c"># Other filters: TBI</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Filter:&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">filter</span><span class="p">)</span><span class="o">+</span><span class="s">&#39; not yet implemented.&#39;</span><span class="p">)</span>

        <span class="c"># We could input a kernel and do a convolution:</span>

        <span class="c"># EG:</span>
        <span class="c"># kernel =  np.array([ [ 1, 1, 1], [ 0, 0, 0], [-1,-1,-1]], np.float_)</span>
        <span class="c"># output = ndimage.convolve(image,kernel)</span>
</pre></div></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">Trace slits v0.1 documentation</a> &raquo;</li>
          <li><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Gemini Observatory.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>